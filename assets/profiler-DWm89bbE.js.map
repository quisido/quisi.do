{"version":3,"file":"profiler-DWm89bbE.js","sources":["../../../../node_modules/@datadog/browser-rum-core/esm/transport/formDataTransport.js","../../../../node_modules/@datadog/browser-rum/esm/domain/profiling/utils/getNumberOfSamples.js","../../../../node_modules/@datadog/browser-rum/esm/domain/profiling/utils/longTaskRegistry.js","../../../../node_modules/@datadog/browser-rum/esm/domain/profiling/profilingCorrelation.js","../../../../node_modules/@datadog/browser-rum/esm/domain/profiling/utils/getDefaultViewName.js","../../../../node_modules/@datadog/browser-rum/esm/domain/profiling/utils/getCustomOrDefaultViewName.js","../../../../node_modules/@datadog/browser-rum/esm/domain/profiling/transport/buildProfileEventAttributes.js","../../../../node_modules/@datadog/browser-rum/esm/domain/profiling/transport/assembly.js","../../../../node_modules/@datadog/browser-rum/esm/domain/profiling/profiler.js"],"sourcesContent":["import { addTelemetryDebug, createHttpRequest, jsonStringify, objectEntries } from '@datadog/browser-core';\nexport function createFormDataTransport(configuration, lifeCycle, createEncoder, streamId) {\n    const reportError = (error) => {\n        lifeCycle.notify(14 /* LifeCycleEventType.RAW_ERROR_COLLECTED */, { error });\n        // monitor-until: forever, to keep an eye on the errors reported to customers\n        addTelemetryDebug('Error reported to customer', { 'error.message': error.message });\n    };\n    const httpRequest = createHttpRequest([configuration.profilingEndpointBuilder], reportError);\n    const encoder = createEncoder(streamId);\n    return {\n        async send({ event, ...attachments }) {\n            const formData = new FormData();\n            const serializedEvent = jsonStringify(event);\n            if (!serializedEvent) {\n                throw new Error('Failed to serialize event');\n            }\n            formData.append('event', new Blob([serializedEvent], { type: 'application/json' }), 'event.json');\n            let bytesCount = serializedEvent.length;\n            for (const [key, value] of objectEntries(attachments)) {\n                const serializedValue = jsonStringify(value);\n                if (!serializedValue) {\n                    throw new Error('Failed to serialize attachment');\n                }\n                const result = await encode(encoder, serializedValue);\n                bytesCount += result.outputBytesCount;\n                formData.append(key, new Blob([result.output]), key);\n            }\n            httpRequest.send({\n                data: formData,\n                bytesCount,\n            });\n        },\n    };\n}\nfunction encode(encoder, data) {\n    return new Promise((resolve) => {\n        encoder.write(data);\n        encoder.finish((encoderResult) => {\n            resolve(encoderResult);\n        });\n    });\n}\n//# sourceMappingURL=formDataTransport.js.map","/**\n * Counts number of samples when the thread was not idle (stackId is defined)\n *\n * @param samples - Array of collected samples\n * @returns Number of samples\n */\nexport function getNumberOfSamples(samples) {\n    let numberOfSamples = 0;\n    for (const sample of samples) {\n        if (sample.stackId !== undefined) {\n            numberOfSamples++;\n        }\n    }\n    return numberOfSamples;\n}\n//# sourceMappingURL=getNumberOfSamples.js.map","// Maps PerformanceEntry start-time to the corresponding long task id (from RUM LongTaskEvent),\n// We need this to link RUM Long Tasks with RUM Profiler stack traces\n// Given that long task takes at least 50ms and we export profile at least every 60 seconds, we can have up to 1200 entries (60s / 50ms = 1200).\nconst registry = new Map();\nexport function disableLongTaskRegistry() {\n    registry.clear(); // Free-up the memory\n}\n/**\n * Store the long task ID in the registry for the Profiler to link it with the corresponding Profile.\n */\nexport function setLongTaskId(longTaskId, startTime) {\n    registry.set(startTime, longTaskId);\n}\nexport function getLongTaskId(startTime) {\n    return registry.get(startTime);\n}\n/**\n * Delete the Long Task from the registry once we have collected it.\n *\n * @param collectionRelativeTime - The relative time of the collection\n */\nexport function cleanupLongTaskRegistryAfterCollection(collectionRelativeTime) {\n    for (const performanceStartTime of registry.keys()) {\n        if (performanceStartTime < collectionRelativeTime) {\n            // We collected this Long Task already, no need to keep it in the registry.\n            registry.delete(performanceStartTime);\n        }\n    }\n}\n//# sourceMappingURL=longTaskRegistry.js.map","import { RumEventType } from '@datadog/browser-rum-core';\nimport { setLongTaskId } from './utils/longTaskRegistry';\n/**\n * Store the Long Task ID in the registry for the Profiler to link it with the corresponding Profile.\n *\n * @param options - The options for the function\n * @param options.rawRumEvent - The Raw RUM event\n * @param options.startTime - The start time of the event (in this case the Long Task Performance Entry start time)\n */\nexport function mayStoreLongTaskIdForProfilerCorrelation({ rawRumEvent, startTime, }) {\n    if (rawRumEvent.type !== RumEventType.LONG_TASK) {\n        return;\n    }\n    const longTaskId = rawRumEvent.long_task.id;\n    // Store longTaskId in the registry for the Profiler to link it with the corresponding Profile.\n    setLongTaskId(longTaskId, startTime);\n}\n//# sourceMappingURL=profilingCorrelation.js.map","// This is the regex used to extract the path from the url (from SimpleUrlGroupingProcessor.java)\n// It's a bit different from the one in the java code because we removed the lookbehind unsupported by Safari.\nconst PATH_MIXED_ALPHANUMERICS = /\\/(?![vV]\\d{1,2}\\/)([^/\\d?]*\\d+[^/?]*)/g;\nexport function getDefaultViewName(viewPathUrl) {\n    if (!viewPathUrl) {\n        return '/';\n    }\n    // Replace all the mixed alphanumerics with a ?\n    return viewPathUrl.replace(PATH_MIXED_ALPHANUMERICS, '/?');\n}\n//# sourceMappingURL=getDefaultViewName.js.map","import { getDefaultViewName } from './getDefaultViewName';\nexport const getCustomOrDefaultViewName = (customViewName, viewPathUrl) => customViewName || getDefaultViewName(viewPathUrl);\n//# sourceMappingURL=getCustomOrDefaultViewName.js.map","/**\n * Builds attributes for the Profile Event.\n *\n * @param profilerTrace - Profiler trace\n * @param applicationId - application id.\n * @param sessionId - session id.\n * @returns Additional attributes.\n */\nexport function buildProfileEventAttributes(profilerTrace, applicationId, sessionId) {\n    const attributes = {\n        application: {\n            id: applicationId,\n        },\n    };\n    if (sessionId) {\n        attributes.session = {\n            id: sessionId,\n        };\n    }\n    // Extract view ids and names from the profiler trace and add them as attributes of the profile event.\n    // This will be used to filter the profiles by @view.id and/or @view.name.\n    const { ids, names } = extractViewIdsAndNames(profilerTrace.views);\n    if (ids.length) {\n        attributes.view = {\n            id: ids,\n            name: names,\n        };\n    }\n    const longTaskIds = profilerTrace.longTasks.map((longTask) => longTask.id).filter((id) => id !== undefined);\n    if (longTaskIds.length) {\n        attributes.long_task = { id: longTaskIds };\n    }\n    return attributes;\n}\nfunction extractViewIdsAndNames(views) {\n    const result = { ids: [], names: [] };\n    for (const view of views) {\n        result.ids.push(view.viewId);\n        if (view.viewName) {\n            result.names.push(view.viewName);\n        }\n    }\n    // Remove duplicates\n    result.names = Array.from(new Set(result.names));\n    return result;\n}\n//# sourceMappingURL=buildProfileEventAttributes.js.map","import { buildTags, currentDrift } from '@datadog/browser-core';\nimport { buildProfileEventAttributes } from './buildProfileEventAttributes';\nexport function assembleProfilingPayload(profilerTrace, configuration, sessionId) {\n    const event = buildProfileEvent(profilerTrace, configuration, sessionId);\n    return {\n        event,\n        'wall-time.json': profilerTrace,\n    };\n}\nfunction buildProfileEvent(profilerTrace, configuration, sessionId) {\n    const tags = buildTags(configuration); // TODO: get that from the tagContext hook\n    const profileAttributes = buildProfileEventAttributes(profilerTrace, configuration.applicationId, sessionId);\n    const profileEventTags = buildProfileEventTags(tags);\n    const profileEvent = {\n        ...profileAttributes,\n        attachments: ['wall-time.json'],\n        start: new Date(profilerTrace.startClocks.timeStamp).toISOString(),\n        end: new Date(profilerTrace.endClocks.timeStamp).toISOString(),\n        family: 'chrome',\n        runtime: 'chrome',\n        format: 'json',\n        version: 4, // Ingestion event version (not the version application tag)\n        tags_profiler: profileEventTags.join(','),\n        _dd: {\n            clock_drift: currentDrift(),\n        },\n    };\n    return profileEvent;\n}\n/**\n * Builds tags for the Profile Event.\n *\n * @param tags - RUM tags\n * @returns Combined tags for the Profile Event.\n */\nfunction buildProfileEventTags(tags) {\n    // Tags already contains the common tags for all events. (service, env, version, etc.)\n    // Here we are adding some specific-to-profiling tags.\n    const profileEventTags = tags.concat(['language:javascript', 'runtime:chrome', 'family:chrome', 'host:browser']);\n    return profileEventTags;\n}\n//# sourceMappingURL=assembly.js.map","import { addEventListener, clearTimeout, setTimeout, monitorError, display, getGlobalObject, relativeToClocks, clocksOrigin, clocksNow, elapsed, } from '@datadog/browser-core';\nimport { createFormDataTransport, RumPerformanceEntryType, supportPerformanceTimingEvent, } from '@datadog/browser-rum-core';\nimport { getNumberOfSamples } from './utils/getNumberOfSamples';\nimport { cleanupLongTaskRegistryAfterCollection, getLongTaskId } from './utils/longTaskRegistry';\nimport { mayStoreLongTaskIdForProfilerCorrelation } from './profilingCorrelation';\nimport { getCustomOrDefaultViewName } from './utils/getCustomOrDefaultViewName';\nimport { assembleProfilingPayload } from './transport/assembly';\nexport const DEFAULT_RUM_PROFILER_CONFIGURATION = {\n    sampleIntervalMs: 10, // Sample stack trace every 10ms\n    collectIntervalMs: 60000, // Collect data every minute\n    minProfileDurationMs: 5000, // Require at least 5 seconds of profile data to reduce noise and cost\n    minNumberOfSamples: 50, // Require at least 50 samples (~500 ms) to report a profile to reduce noise and cost\n};\nexport function createRumProfiler(configuration, lifeCycle, session, profilingContextManager, createEncoder, profilerConfiguration = DEFAULT_RUM_PROFILER_CONFIGURATION) {\n    const transport = createFormDataTransport(configuration, lifeCycle, createEncoder, 6 /* DeflateEncoderStreamId.PROFILING */);\n    const isLongAnimationFrameEnabled = supportPerformanceTimingEvent(RumPerformanceEntryType.LONG_ANIMATION_FRAME);\n    let lastViewEntry;\n    // Global clean-up tasks for listeners that are not specific to a profiler instance (eg. visibility change, before unload)\n    const globalCleanupTasks = [];\n    let instance = { state: 'stopped' };\n    function start(viewEntry) {\n        if (instance.state === 'running') {\n            return;\n        }\n        // Add initial view\n        // Note: `viewEntry.name` is only filled when users use manual view creation via `startView` method.\n        lastViewEntry = viewEntry\n            ? {\n                startClocks: viewEntry.startClocks,\n                viewId: viewEntry.id,\n                viewName: getCustomOrDefaultViewName(viewEntry.name, document.location.pathname),\n            }\n            : undefined;\n        // Add global clean-up tasks for listeners that are not specific to a profiler instance (eg. visibility change, before unload)\n        globalCleanupTasks.push(addEventListener(configuration, window, \"visibilitychange\" /* DOM_EVENT.VISIBILITY_CHANGE */, handleVisibilityChange).stop, addEventListener(configuration, window, \"beforeunload\" /* DOM_EVENT.BEFORE_UNLOAD */, handleBeforeUnload).stop);\n        // Start profiler instance\n        startNextProfilerInstance();\n    }\n    async function stop() {\n        // Stop current profiler instance\n        await stopProfilerInstance('stopped');\n        // Cleanup global listeners\n        globalCleanupTasks.forEach((task) => task());\n        // Cleanup Long Task Registry as we no longer need to correlate them with RUM\n        cleanupLongTaskRegistryAfterCollection(clocksNow().relative);\n        // Update Profiling status once the Profiler has been stopped.\n        profilingContextManager.set({ status: 'stopped', error_reason: undefined });\n    }\n    /**\n     * Whenever a new Profiler instance is started, we need to add event listeners to surroundings (RUM Events, Long Tasks, etc) to enrich the Profiler data.\n     * If the instance is already running, we can keep the same event listeners.\n     */\n    function addEventListeners(existingInstance) {\n        if (existingInstance.state === 'running') {\n            // Instance is already running, so we can keep same event listeners.\n            return {\n                cleanupTasks: existingInstance.cleanupTasks,\n                observer: existingInstance.observer,\n            };\n        }\n        // Store clean-up tasks for this instance (tasks to be executed when the Profiler is stopped or paused.)\n        const cleanupTasks = [];\n        let observer;\n        // Register everything linked to Long Tasks correlations with RUM, when enabled.\n        if (configuration.trackLongTasks) {\n            // Setup event listeners, and since we only listen to Long Tasks for now, we activate the Performance Observer only when they are tracked.\n            observer = new PerformanceObserver(handlePerformance);\n            observer.observe({\n                entryTypes: [getLongTaskEntryType()],\n            });\n            // Whenever an Event is collected, when it's a Long Task, we may store the long task id for profiler correlation.\n            const rawEventCollectedSubscription = lifeCycle.subscribe(12 /* LifeCycleEventType.RAW_RUM_EVENT_COLLECTED */, (data) => {\n                mayStoreLongTaskIdForProfilerCorrelation(data);\n            });\n            cleanupTasks.push(() => observer === null || observer === void 0 ? void 0 : observer.disconnect());\n            cleanupTasks.push(rawEventCollectedSubscription.unsubscribe);\n        }\n        // Whenever the View is updated, we add a views entry to the profiler instance.\n        const viewUpdatedSubscription = lifeCycle.subscribe(2 /* LifeCycleEventType.VIEW_CREATED */, (view) => {\n            const viewEntry = {\n                viewId: view.id,\n                // Note: `viewName` is only filled when users use manual view creation via `startView` method.\n                viewName: getCustomOrDefaultViewName(view.name, document.location.pathname),\n                startClocks: view.startClocks,\n            };\n            collectViewEntry(viewEntry);\n            // Update last view entry\n            lastViewEntry = viewEntry;\n        });\n        cleanupTasks.push(viewUpdatedSubscription.unsubscribe);\n        return {\n            cleanupTasks,\n            observer,\n        };\n    }\n    function startNextProfilerInstance() {\n        // These APIs might be unavailable in some browsers\n        const globalThisProfiler = getGlobalObject().Profiler;\n        if (!globalThisProfiler) {\n            profilingContextManager.set({ status: 'error', error_reason: 'not-supported-by-browser' });\n            throw new Error('RUM Profiler is not supported in this browser.');\n        }\n        // Don't wait for data collection to start next instance\n        collectProfilerInstance(instance).catch(monitorError);\n        const { cleanupTasks, observer } = addEventListeners(instance);\n        let profiler;\n        try {\n            // We have to create new Profiler each time we start a new instance\n            profiler = new globalThisProfiler({\n                sampleInterval: profilerConfiguration.sampleIntervalMs,\n                // Keep buffer size at 1.5 times of minimum required to collect data for a profiling instance\n                maxBufferSize: Math.round((profilerConfiguration.collectIntervalMs * 1.5) / profilerConfiguration.sampleIntervalMs),\n            });\n        }\n        catch (e) {\n            if (e instanceof Error && e.message.includes('disabled by Document Policy')) {\n                // Missing Response Header (`js-profiling`) that is required to enable the profiler.\n                // We should suggest the user to enable the Response Header in their server configuration.\n                display.warn('[DD_RUM] Profiler startup failed. Ensure your server includes the `Document-Policy: js-profiling` response header when serving HTML pages.', e);\n                profilingContextManager.set({ status: 'error', error_reason: 'missing-document-policy-header' });\n            }\n            else {\n                profilingContextManager.set({ status: 'error', error_reason: 'unexpected-exception' });\n            }\n            return;\n        }\n        profilingContextManager.set({ status: 'running', error_reason: undefined });\n        // Kick-off the new instance\n        instance = {\n            state: 'running',\n            startClocks: clocksNow(),\n            profiler,\n            timeoutId: setTimeout(startNextProfilerInstance, profilerConfiguration.collectIntervalMs),\n            longTasks: [],\n            views: [],\n            cleanupTasks,\n            observer,\n        };\n        // Add last view entry\n        collectViewEntry(lastViewEntry);\n        // Add event handler case we overflow the buffer\n        profiler.addEventListener('samplebufferfull', handleSampleBufferFull);\n    }\n    async function collectProfilerInstance(lastInstance) {\n        var _a, _b;\n        if (lastInstance.state !== 'running') {\n            return;\n        }\n        // Empty the performance observer buffer\n        handleLongTaskEntries((_b = (_a = lastInstance.observer) === null || _a === void 0 ? void 0 : _a.takeRecords()) !== null && _b !== void 0 ? _b : []);\n        // Cleanup instance\n        clearTimeout(lastInstance.timeoutId);\n        lastInstance.profiler.removeEventListener('samplebufferfull', handleSampleBufferFull);\n        // Store instance data snapshot in local variables to use in async callback\n        const { startClocks, longTasks, views } = lastInstance;\n        // Capturing when we stop the profiler so we use this time as a reference to clean-up long task registry, eg. remove the long tasks that we collected already\n        const collectClocks = clocksNow();\n        // Stop current profiler to get trace\n        await lastInstance.profiler\n            .stop()\n            .then((trace) => {\n            const endClocks = clocksNow();\n            const hasLongTasks = longTasks.length > 0;\n            const isBelowDurationThreshold = elapsed(startClocks.timeStamp, endClocks.timeStamp) < profilerConfiguration.minProfileDurationMs;\n            const isBelowSampleThreshold = getNumberOfSamples(trace.samples) < profilerConfiguration.minNumberOfSamples;\n            if (!hasLongTasks && (isBelowDurationThreshold || isBelowSampleThreshold)) {\n                // Skip very short profiles to reduce noise and cost, but keep them if they contain long tasks.\n                return;\n            }\n            handleProfilerTrace(\n            // Enrich trace with time and instance data\n            Object.assign(trace, {\n                startClocks,\n                endClocks,\n                clocksOrigin: clocksOrigin(),\n                longTasks,\n                views,\n                sampleInterval: profilerConfiguration.sampleIntervalMs,\n            }));\n            // Clear long task registry, remove entries that we collected already (eg. avoid slowly growing memory usage by keeping outdated entries)\n            cleanupLongTaskRegistryAfterCollection(collectClocks.relative);\n        })\n            .catch(monitorError);\n    }\n    async function stopProfilerInstance(nextState) {\n        if (instance.state !== 'running') {\n            return;\n        }\n        // Cleanup tasks\n        instance.cleanupTasks.forEach((cleanupTask) => cleanupTask());\n        await collectProfilerInstance(instance);\n        instance = { state: nextState };\n    }\n    function collectViewEntry(viewEntry) {\n        if (instance.state !== 'running' || !viewEntry) {\n            return;\n        }\n        // Add entry to views\n        instance.views.push(viewEntry);\n    }\n    function handleProfilerTrace(trace) {\n        var _a;\n        // Find current session to assign it to the Profile.\n        const sessionId = (_a = session.findTrackedSession()) === null || _a === void 0 ? void 0 : _a.id;\n        const payload = assembleProfilingPayload(trace, configuration, sessionId);\n        void transport.send(payload);\n    }\n    function handleSampleBufferFull() {\n        startNextProfilerInstance();\n    }\n    function handlePerformance(list) {\n        handleLongTaskEntries(list.getEntries());\n    }\n    function handleLongTaskEntries(entries) {\n        if (instance.state !== 'running') {\n            return;\n        }\n        for (const entry of entries) {\n            if (entry.duration < profilerConfiguration.sampleIntervalMs) {\n                // Skip entries shorter than sample interval to reduce noise and size of profile\n                continue;\n            }\n            const startClocks = relativeToClocks(entry.startTime);\n            const longTaskId = getLongTaskId(startClocks.relative);\n            // Store Long Task entry, which is a lightweight version of the PerformanceEntry\n            instance.longTasks.push({\n                id: longTaskId,\n                duration: entry.duration,\n                entryType: entry.entryType,\n                startClocks,\n            });\n        }\n    }\n    function handleVisibilityChange() {\n        if (document.visibilityState === 'hidden' && instance.state === 'running') {\n            // Pause when tab is hidden. We use paused state to distinguish between\n            // paused by visibility change and stopped by user.\n            // If profiler is paused by the visibility change, we should resume when\n            // tab becomes visible again. That's not the case when user stops the profiler.\n            stopProfilerInstance('paused').catch(monitorError);\n        }\n        else if (document.visibilityState === 'visible' && instance.state === 'paused') {\n            // Resume when tab becomes visible again\n            startNextProfilerInstance();\n        }\n    }\n    function handleBeforeUnload() {\n        // `unload` can in some cases be triggered while the page is still active (link to a different protocol like mailto:).\n        // We can immediately flush (by starting a new profiler instance) to make sure we receive the data, and at the same time keep the profiler active.\n        // In case of the regular unload, the profiler will be shut down anyway.\n        startNextProfilerInstance();\n    }\n    function getLongTaskEntryType() {\n        return isLongAnimationFrameEnabled ? 'long-animation-frame' : 'longtask';\n    }\n    function isStopped() {\n        return instance.state === 'stopped';\n    }\n    function isRunning() {\n        return instance.state === 'running';\n    }\n    function isPaused() {\n        return instance.state === 'paused';\n    }\n    return { start, stop, isStopped, isRunning, isPaused };\n}\n//# sourceMappingURL=profiler.js.map"],"names":["createFormDataTransport","configuration","lifeCycle","createEncoder","streamId","reportError","error","addTelemetryDebug","httpRequest","createHttpRequest","encoder","event","attachments","formData","serializedEvent","jsonStringify","bytesCount","key","value","objectEntries","serializedValue","result","encode","data","resolve","encoderResult","getNumberOfSamples","samples","numberOfSamples","sample","registry","setLongTaskId","longTaskId","startTime","getLongTaskId","cleanupLongTaskRegistryAfterCollection","collectionRelativeTime","performanceStartTime","mayStoreLongTaskIdForProfilerCorrelation","rawRumEvent","RumEventType","PATH_MIXED_ALPHANUMERICS","getDefaultViewName","viewPathUrl","getCustomOrDefaultViewName","customViewName","buildProfileEventAttributes","profilerTrace","applicationId","sessionId","attributes","ids","names","extractViewIdsAndNames","longTaskIds","longTask","id","views","view","assembleProfilingPayload","buildProfileEvent","tags","buildTags","profileAttributes","profileEventTags","buildProfileEventTags","currentDrift","DEFAULT_RUM_PROFILER_CONFIGURATION","createRumProfiler","session","profilingContextManager","profilerConfiguration","transport","isLongAnimationFrameEnabled","supportPerformanceTimingEvent","RumPerformanceEntryType","lastViewEntry","globalCleanupTasks","instance","start","viewEntry","addEventListener","handleVisibilityChange","handleBeforeUnload","startNextProfilerInstance","stop","stopProfilerInstance","task","clocksNow","addEventListeners","existingInstance","cleanupTasks","observer","handlePerformance","getLongTaskEntryType","rawEventCollectedSubscription","viewUpdatedSubscription","collectViewEntry","globalThisProfiler","getGlobalObject","collectProfilerInstance","monitorError","profiler","e","display","setTimeout","handleSampleBufferFull","lastInstance","_a","_b","handleLongTaskEntries","clearTimeout","startClocks","longTasks","collectClocks","trace","endClocks","hasLongTasks","isBelowDurationThreshold","elapsed","isBelowSampleThreshold","handleProfilerTrace","clocksOrigin","nextState","cleanupTask","payload","list","entries","entry","relativeToClocks","isStopped","isRunning","isPaused"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8]}