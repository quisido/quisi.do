{"version":3,"file":"startRecording-OlklP3yh.js","sources":["../../../../node_modules/@datadog/browser-rum/esm/domain/record/serialization/serializationUtils.js","../../../../node_modules/@datadog/browser-rum/esm/types/sessionReplayConstants.js","../../../../node_modules/@datadog/browser-rum/esm/domain/record/serialization/serializeStyleSheets.js","../../../../node_modules/@datadog/browser-rum/esm/domain/record/serialization/serializeAttribute.js","../../../../node_modules/@datadog/browser-rum/esm/domain/record/serialization/serializeAttributes.js","../../../../node_modules/@datadog/browser-rum/esm/domain/record/serialization/serializeNode.js","../../../../node_modules/@datadog/browser-rum/esm/domain/record/serialization/serializeDocument.js","../../../../node_modules/@datadog/browser-rum/esm/domain/record/eventsUtils.js","../../../../node_modules/@datadog/browser-rum/esm/domain/record/viewports.js","../../../../node_modules/@datadog/browser-rum/esm/domain/record/assembly.js","../../../../node_modules/@datadog/browser-rum/esm/domain/record/trackers/trackMove.js","../../../../node_modules/@datadog/browser-rum/esm/domain/record/trackers/trackMouseInteraction.js","../../../../node_modules/@datadog/browser-rum/esm/domain/record/trackers/trackScroll.js","../../../../node_modules/@datadog/browser-rum/esm/domain/record/trackers/trackViewportResize.js","../../../../node_modules/@datadog/browser-rum/esm/domain/record/trackers/trackMediaInteraction.js","../../../../node_modules/@datadog/browser-rum/esm/domain/record/trackers/trackStyleSheet.js","../../../../node_modules/@datadog/browser-rum/esm/domain/record/trackers/trackFocus.js","../../../../node_modules/@datadog/browser-rum/esm/domain/record/trackers/trackFrustration.js","../../../../node_modules/@datadog/browser-rum/esm/domain/record/trackers/trackViewEnd.js","../../../../node_modules/@datadog/browser-rum/esm/domain/record/trackers/trackInput.js","../../../../node_modules/@datadog/browser-rum/esm/domain/record/mutationBatch.js","../../../../node_modules/@datadog/browser-rum/esm/domain/record/trackers/trackMutation.js","../../../../node_modules/@datadog/browser-rum/esm/domain/record/elementsScrollPositions.js","../../../../node_modules/@datadog/browser-rum/esm/domain/record/shadowRootsController.js","../../../../node_modules/@datadog/browser-rum/esm/domain/record/startFullSnapshots.js","../../../../node_modules/@datadog/browser-rum/esm/domain/record/recordIds.js","../../../../node_modules/@datadog/browser-rum/esm/domain/record/record.js","../../../../node_modules/@datadog/browser-rum/esm/domain/segmentCollection/buildReplayPayload.js","../../../../node_modules/@datadog/browser-rum/esm/domain/segmentCollection/segment.js","../../../../node_modules/@datadog/browser-rum/esm/domain/segmentCollection/segmentCollection.js","../../../../node_modules/@datadog/browser-rum/esm/domain/startRecordBridge.js","../../../../node_modules/@datadog/browser-rum/esm/boot/startRecording.js"],"sourcesContent":["import { buildUrl } from '@datadog/browser-core';\nimport { getParentNode, isNodeShadowRoot, CENSORED_STRING_MARK, shouldMaskNode } from '@datadog/browser-rum-core';\nconst serializedNodeIds = new WeakMap();\nexport function hasSerializedNode(node) {\n    return serializedNodeIds.has(node);\n}\nexport function nodeAndAncestorsHaveSerializedNode(node) {\n    let current = node;\n    while (current) {\n        if (!hasSerializedNode(current) && !isNodeShadowRoot(current)) {\n            return false;\n        }\n        current = getParentNode(current);\n    }\n    return true;\n}\nexport function getSerializedNodeId(node) {\n    return serializedNodeIds.get(node);\n}\nexport function setSerializedNodeId(node, serializeNodeId) {\n    serializedNodeIds.set(node, serializeNodeId);\n}\n/**\n * Get the element \"value\" to be serialized as an attribute or an input update record. It respects\n * the input privacy mode of the element.\n * PERFROMANCE OPTIMIZATION: Assumes that privacy level `HIDDEN` is never encountered because of earlier checks.\n */\nexport function getElementInputValue(element, nodePrivacyLevel) {\n    /*\n     BROWSER SPEC NOTE: <input>, <select>\n     For some <input> elements, the `value` is an exceptional property/attribute that has the\n     value synced between el.value and el.getAttribute()\n     input[type=button,checkbox,hidden,image,radio,reset,submit]\n     */\n    const tagName = element.tagName;\n    const value = element.value;\n    if (shouldMaskNode(element, nodePrivacyLevel)) {\n        const type = element.type;\n        if (tagName === 'INPUT' && (type === 'button' || type === 'submit' || type === 'reset')) {\n            // Overrule `MASK` privacy level for button-like element values, as they are used during replay\n            // to display their label. They can still be hidden via the \"hidden\" privacy attribute or class name.\n            return value;\n        }\n        else if (!value || tagName === 'OPTION') {\n            // <Option> value provides no benefit\n            return;\n        }\n        return CENSORED_STRING_MARK;\n    }\n    if (tagName === 'OPTION' || tagName === 'SELECT') {\n        return element.value;\n    }\n    if (tagName !== 'INPUT' && tagName !== 'TEXTAREA') {\n        return;\n    }\n    return value;\n}\nexport const URL_IN_CSS_REF = /url\\((?:(')([^']*)'|(\")([^\"]*)\"|([^)]*))\\)/gm;\nexport const ABSOLUTE_URL = /^[A-Za-z]+:|^\\/\\//;\nexport const DATA_URI = /^[\"']?data:.*,/i;\nexport function switchToAbsoluteUrl(cssText, cssHref) {\n    return cssText.replace(URL_IN_CSS_REF, (matchingSubstring, singleQuote, urlWrappedInSingleQuotes, doubleQuote, urlWrappedInDoubleQuotes, urlNotWrappedInQuotes) => {\n        const url = urlWrappedInSingleQuotes || urlWrappedInDoubleQuotes || urlNotWrappedInQuotes;\n        if (!cssHref || !url || ABSOLUTE_URL.test(url) || DATA_URI.test(url)) {\n            return matchingSubstring;\n        }\n        const quote = singleQuote || doubleQuote || '';\n        return `url(${quote}${makeUrlAbsolute(url, cssHref)}${quote})`;\n    });\n}\nexport function makeUrlAbsolute(url, baseUrl) {\n    try {\n        return buildUrl(url, baseUrl).href;\n    }\n    catch (_a) {\n        return url;\n    }\n}\nconst TAG_NAME_REGEX = /[^a-z1-6-_]/;\nexport function getValidTagName(tagName) {\n    const processedTagName = tagName.toLowerCase().trim();\n    if (TAG_NAME_REGEX.test(processedTagName)) {\n        // if the tag name is odd and we cannot extract\n        // anything from the string, then we return a\n        // generic div\n        return 'div';\n    }\n    return processedTagName;\n}\nexport function censoredImageForSize(width, height) {\n    return `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='${width}' height='${height}' style='background-color:silver'%3E%3C/svg%3E`;\n}\n//# sourceMappingURL=serializationUtils.js.map","export const RecordType = {\n    FullSnapshot: 2,\n    IncrementalSnapshot: 3,\n    Meta: 4,\n    Focus: 6,\n    ViewEnd: 7,\n    VisualViewport: 8,\n    FrustrationRecord: 9,\n};\nexport const NodeType = {\n    Document: 0,\n    DocumentType: 1,\n    Element: 2,\n    Text: 3,\n    CDATA: 4,\n    DocumentFragment: 11,\n};\nexport const IncrementalSource = {\n    Mutation: 0,\n    MouseMove: 1,\n    MouseInteraction: 2,\n    Scroll: 3,\n    ViewportResize: 4,\n    Input: 5,\n    TouchMove: 6,\n    MediaInteraction: 7,\n    StyleSheetRule: 8,\n    // CanvasMutation : 9,\n    // Font : 10,\n};\nexport const MouseInteractionType = {\n    MouseUp: 0,\n    MouseDown: 1,\n    Click: 2,\n    ContextMenu: 3,\n    DblClick: 4,\n    Focus: 5,\n    Blur: 6,\n    TouchStart: 7,\n    TouchEnd: 9,\n};\nexport const MediaInteractionType = {\n    Play: 0,\n    Pause: 1,\n};\n//# sourceMappingURL=sessionReplayConstants.js.map","export function serializeStyleSheets(cssStyleSheets) {\n    if (cssStyleSheets === undefined || cssStyleSheets.length === 0) {\n        return undefined;\n    }\n    return cssStyleSheets.map((cssStyleSheet) => {\n        const rules = cssStyleSheet.cssRules || cssStyleSheet.rules;\n        const cssRules = Array.from(rules, (cssRule) => cssRule.cssText);\n        const styleSheet = {\n            cssRules,\n            disabled: cssStyleSheet.disabled || undefined,\n            media: cssStyleSheet.media.length > 0 ? Array.from(cssStyleSheet.media) : undefined,\n        };\n        return styleSheet;\n    });\n}\n//# sourceMappingURL=serializeStyleSheets.js.map","import { NodePrivacyLevel, PRIVACY_ATTR_NAME, CENSORED_STRING_MARK, CENSORED_IMG_MARK, STABLE_ATTRIBUTES, sanitizeIfLongDataUrl, } from '@datadog/browser-rum-core';\nimport { censoredImageForSize } from './serializationUtils';\n// TODO: temporarily bump the Session Replay limit to 1Mb for dataUrls\n// This limit should be removed after [PANA-2843] is implemented\nexport const MAX_ATTRIBUTE_VALUE_CHAR_LENGTH = 1000000;\nexport function serializeAttribute(element, nodePrivacyLevel, attributeName, configuration) {\n    if (nodePrivacyLevel === NodePrivacyLevel.HIDDEN) {\n        // dup condition for direct access case\n        return null;\n    }\n    const attributeValue = element.getAttribute(attributeName);\n    if (nodePrivacyLevel === NodePrivacyLevel.MASK &&\n        attributeName !== PRIVACY_ATTR_NAME &&\n        !STABLE_ATTRIBUTES.includes(attributeName) &&\n        attributeName !== configuration.actionNameAttribute) {\n        const tagName = element.tagName;\n        switch (attributeName) {\n            // Mask Attribute text content\n            case 'title':\n            case 'alt':\n            case 'placeholder':\n                return CENSORED_STRING_MARK;\n        }\n        // mask image URLs\n        if (tagName === 'IMG' && (attributeName === 'src' || attributeName === 'srcset')) {\n            // generate image with similar dimension than the original to have the same rendering behaviour\n            const image = element;\n            if (image.naturalWidth > 0) {\n                return censoredImageForSize(image.naturalWidth, image.naturalHeight);\n            }\n            const { width, height } = element.getBoundingClientRect();\n            if (width > 0 || height > 0) {\n                return censoredImageForSize(width, height);\n            }\n            // if we can't get the image size, fallback to the censored image\n            return CENSORED_IMG_MARK;\n        }\n        // mask source URLs\n        if (tagName === 'SOURCE' && (attributeName === 'src' || attributeName === 'srcset')) {\n            return CENSORED_IMG_MARK;\n        }\n        // mask <a> URLs\n        if (tagName === 'A' && attributeName === 'href') {\n            return CENSORED_STRING_MARK;\n        }\n        // mask data-* attributes\n        if (attributeValue && attributeName.startsWith('data-')) {\n            // Exception: it's safe to reveal the `${PRIVACY_ATTR_NAME}` attr\n            return CENSORED_STRING_MARK;\n        }\n        // mask iframe srcdoc\n        if (tagName === 'IFRAME' && attributeName === 'srcdoc') {\n            return CENSORED_STRING_MARK;\n        }\n    }\n    if (!attributeValue || typeof attributeValue !== 'string') {\n        return attributeValue;\n    }\n    return sanitizeIfLongDataUrl(attributeValue, MAX_ATTRIBUTE_VALUE_CHAR_LENGTH);\n}\n//# sourceMappingURL=serializeAttribute.js.map","import { NodePrivacyLevel, shouldMaskNode } from '@datadog/browser-rum-core';\nimport { isSafari } from '@datadog/browser-core';\nimport { getElementInputValue, switchToAbsoluteUrl, getValidTagName } from './serializationUtils';\nimport { serializeAttribute } from './serializeAttribute';\nexport function serializeAttributes(element, nodePrivacyLevel, options) {\n    if (nodePrivacyLevel === NodePrivacyLevel.HIDDEN) {\n        return {};\n    }\n    const safeAttrs = {};\n    const tagName = getValidTagName(element.tagName);\n    const doc = element.ownerDocument;\n    for (let i = 0; i < element.attributes.length; i += 1) {\n        const attribute = element.attributes.item(i);\n        const attributeName = attribute.name;\n        const attributeValue = serializeAttribute(element, nodePrivacyLevel, attributeName, options.configuration);\n        if (attributeValue !== null) {\n            safeAttrs[attributeName] = attributeValue;\n        }\n    }\n    if (element.value &&\n        (tagName === 'textarea' || tagName === 'select' || tagName === 'option' || tagName === 'input')) {\n        const formValue = getElementInputValue(element, nodePrivacyLevel);\n        if (formValue !== undefined) {\n            safeAttrs.value = formValue;\n        }\n    }\n    /**\n     * <Option> can be selected, which occurs if its `value` matches ancestor `<Select>.value`\n     */\n    if (tagName === 'option' && nodePrivacyLevel === NodePrivacyLevel.ALLOW) {\n        // For privacy=`MASK`, all the values would be the same, so skip.\n        const optionElement = element;\n        if (optionElement.selected) {\n            safeAttrs.selected = optionElement.selected;\n        }\n    }\n    // remote css\n    if (tagName === 'link') {\n        const stylesheet = Array.from(doc.styleSheets).find((s) => s.href === element.href);\n        const cssText = getCssRulesString(stylesheet);\n        if (cssText && stylesheet) {\n            safeAttrs._cssText = cssText;\n        }\n    }\n    // dynamic stylesheet\n    if (tagName === 'style' && element.sheet) {\n        const cssText = getCssRulesString(element.sheet);\n        if (cssText) {\n            safeAttrs._cssText = cssText;\n        }\n    }\n    /**\n     * Forms: input[type=checkbox,radio]\n     * The `checked` property for <input> is a little bit special:\n     * 1. el.checked is a setter that returns if truthy.\n     * 2. getAttribute returns the string value\n     * getAttribute('checked') does not sync with `Element.checked`, so use JS property\n     * NOTE: `checked` property exists on `HTMLInputElement`. For serializer assumptions, we check for type=radio|check.\n     */\n    const inputElement = element;\n    if (tagName === 'input' && (inputElement.type === 'radio' || inputElement.type === 'checkbox')) {\n        if (nodePrivacyLevel === NodePrivacyLevel.ALLOW) {\n            safeAttrs.checked = !!inputElement.checked;\n        }\n        else if (shouldMaskNode(inputElement, nodePrivacyLevel)) {\n            delete safeAttrs.checked;\n        }\n    }\n    /**\n     * Serialize the media playback state\n     */\n    if (tagName === 'audio' || tagName === 'video') {\n        const mediaElement = element;\n        safeAttrs.rr_mediaState = mediaElement.paused ? 'paused' : 'played';\n    }\n    /**\n     * Serialize the scroll state for each element only for full snapshot\n     */\n    let scrollTop;\n    let scrollLeft;\n    const serializationContext = options.serializationContext;\n    switch (serializationContext.status) {\n        case 0 /* SerializationContextStatus.INITIAL_FULL_SNAPSHOT */:\n            scrollTop = Math.round(element.scrollTop);\n            scrollLeft = Math.round(element.scrollLeft);\n            if (scrollTop || scrollLeft) {\n                serializationContext.elementsScrollPositions.set(element, { scrollTop, scrollLeft });\n            }\n            break;\n        case 1 /* SerializationContextStatus.SUBSEQUENT_FULL_SNAPSHOT */:\n            if (serializationContext.elementsScrollPositions.has(element)) {\n                ;\n                ({ scrollTop, scrollLeft } = serializationContext.elementsScrollPositions.get(element));\n            }\n            break;\n    }\n    if (scrollLeft) {\n        safeAttrs.rr_scrollLeft = scrollLeft;\n    }\n    if (scrollTop) {\n        safeAttrs.rr_scrollTop = scrollTop;\n    }\n    return safeAttrs;\n}\nexport function getCssRulesString(cssStyleSheet) {\n    if (!cssStyleSheet) {\n        return null;\n    }\n    let rules;\n    try {\n        rules = cssStyleSheet.rules || cssStyleSheet.cssRules;\n    }\n    catch (_a) {\n        // if css is protected by CORS we cannot access cssRules see: https://www.w3.org/TR/cssom-1/#the-cssstylesheet-interface\n    }\n    if (!rules) {\n        return null;\n    }\n    const styleSheetCssText = Array.from(rules, isSafari() ? getCssRuleStringForSafari : getCssRuleString).join('');\n    return switchToAbsoluteUrl(styleSheetCssText, cssStyleSheet.href);\n}\nfunction getCssRuleStringForSafari(rule) {\n    // Safari does not escape attribute selectors containing : properly\n    // https://bugs.webkit.org/show_bug.cgi?id=184604\n    if (isCSSStyleRule(rule) && rule.selectorText.includes(':')) {\n        // This regex replaces [foo:bar] by [foo\\\\:bar]\n        const escapeColon = /(\\[[\\w-]+[^\\\\])(:[^\\]]+\\])/g;\n        return rule.cssText.replace(escapeColon, '$1\\\\$2');\n    }\n    return getCssRuleString(rule);\n}\nfunction getCssRuleString(rule) {\n    // If it's an @import rule, try to inline sub-rules recursively with `getCssRulesString`. This\n    // operation can fail if the imported stylesheet is protected by CORS, in which case we fallback\n    // to the @import rule CSS text.\n    return (isCSSImportRule(rule) && getCssRulesString(rule.styleSheet)) || rule.cssText;\n}\nfunction isCSSImportRule(rule) {\n    return 'styleSheet' in rule;\n}\nfunction isCSSStyleRule(rule) {\n    return 'selectorText' in rule;\n}\n//# sourceMappingURL=serializeAttributes.js.map","import { reducePrivacyLevel, getNodeSelfPrivacyLevel, getTextContent, isNodeShadowRoot, hasChildNodes, forEachChildNodes, NodePrivacyLevel, PRIVACY_ATTR_NAME, PRIVACY_ATTR_VALUE_HIDDEN, } from '@datadog/browser-rum-core';\nimport { NodeType } from '../../../types';\nimport { getSerializedNodeId, getValidTagName, setSerializedNodeId } from './serializationUtils';\nimport { serializeStyleSheets } from './serializeStyleSheets';\nimport { serializeAttributes } from './serializeAttributes';\nexport function serializeNodeWithId(node, options) {\n    const serializedNode = serializeNode(node, options);\n    if (!serializedNode) {\n        return null;\n    }\n    // Try to reuse the previous id\n    const id = getSerializedNodeId(node) || generateNextId();\n    const serializedNodeWithId = serializedNode;\n    serializedNodeWithId.id = id;\n    setSerializedNodeId(node, id);\n    if (options.serializedNodeIds) {\n        options.serializedNodeIds.add(id);\n    }\n    return serializedNodeWithId;\n}\nlet _nextId = 1;\nexport function generateNextId() {\n    return _nextId++;\n}\nexport function serializeChildNodes(node, options) {\n    const result = [];\n    forEachChildNodes(node, (childNode) => {\n        const serializedChildNode = serializeNodeWithId(childNode, options);\n        if (serializedChildNode) {\n            result.push(serializedChildNode);\n        }\n    });\n    return result;\n}\nfunction serializeNode(node, options) {\n    switch (node.nodeType) {\n        case node.DOCUMENT_NODE:\n            return serializeDocumentNode(node, options);\n        case node.DOCUMENT_FRAGMENT_NODE:\n            return serializeDocumentFragmentNode(node, options);\n        case node.DOCUMENT_TYPE_NODE:\n            return serializeDocumentTypeNode(node);\n        case node.ELEMENT_NODE:\n            return serializeElementNode(node, options);\n        case node.TEXT_NODE:\n            return serializeTextNode(node, options);\n        case node.CDATA_SECTION_NODE:\n            return serializeCDataNode();\n    }\n}\nexport function serializeDocumentNode(document, options) {\n    return {\n        type: NodeType.Document,\n        childNodes: serializeChildNodes(document, options),\n        adoptedStyleSheets: serializeStyleSheets(document.adoptedStyleSheets),\n    };\n}\nfunction serializeDocumentFragmentNode(element, options) {\n    const isShadowRoot = isNodeShadowRoot(element);\n    if (isShadowRoot) {\n        options.serializationContext.shadowRootsController.addShadowRoot(element);\n    }\n    return {\n        type: NodeType.DocumentFragment,\n        childNodes: serializeChildNodes(element, options),\n        isShadowRoot,\n        adoptedStyleSheets: isShadowRoot ? serializeStyleSheets(element.adoptedStyleSheets) : undefined,\n    };\n}\nfunction serializeDocumentTypeNode(documentType) {\n    return {\n        type: NodeType.DocumentType,\n        name: documentType.name,\n        publicId: documentType.publicId,\n        systemId: documentType.systemId,\n    };\n}\n/**\n * Serializing Element nodes involves capturing:\n * 1. HTML ATTRIBUTES:\n * 2. JS STATE:\n * - scroll offsets\n * - Form fields (input value, checkbox checked, option selection, range)\n * - Canvas state,\n * - Media (video/audio) play mode + currentTime\n * - iframe contents\n * - webcomponents\n * 3. CUSTOM PROPERTIES:\n * - height+width for when `hidden` to cover the element\n * 4. EXCLUDED INTERACTION STATE:\n * - focus (possible, but not worth perf impact)\n * - hover (tracked only via mouse activity)\n * - fullscreen mode\n */\nfunction serializeElementNode(element, options) {\n    const tagName = getValidTagName(element.tagName);\n    const isSVG = isSVGElement(element) || undefined;\n    // For performance reason, we don't use getNodePrivacyLevel directly: we leverage the\n    // parentNodePrivacyLevel option to avoid iterating over all parents\n    const nodePrivacyLevel = reducePrivacyLevel(getNodeSelfPrivacyLevel(element), options.parentNodePrivacyLevel);\n    if (nodePrivacyLevel === NodePrivacyLevel.HIDDEN) {\n        const { width, height } = element.getBoundingClientRect();\n        return {\n            type: NodeType.Element,\n            tagName,\n            attributes: {\n                rr_width: `${width}px`,\n                rr_height: `${height}px`,\n                [PRIVACY_ATTR_NAME]: PRIVACY_ATTR_VALUE_HIDDEN,\n            },\n            childNodes: [],\n            isSVG,\n        };\n    }\n    // Ignore Elements like Script and some Link, Metas\n    if (nodePrivacyLevel === NodePrivacyLevel.IGNORE) {\n        return;\n    }\n    const attributes = serializeAttributes(element, nodePrivacyLevel, options);\n    let childNodes = [];\n    if (hasChildNodes(element) &&\n        // Do not serialize style children as the css rules are already in the _cssText attribute\n        tagName !== 'style') {\n        // OBJECT POOLING OPTIMIZATION:\n        // We should not create a new object systematically as it could impact performances. Try to reuse\n        // the same object as much as possible, and clone it only if we need to.\n        let childNodesSerializationOptions;\n        if (options.parentNodePrivacyLevel === nodePrivacyLevel && options.ignoreWhiteSpace === (tagName === 'head')) {\n            childNodesSerializationOptions = options;\n        }\n        else {\n            childNodesSerializationOptions = {\n                ...options,\n                parentNodePrivacyLevel: nodePrivacyLevel,\n                ignoreWhiteSpace: tagName === 'head',\n            };\n        }\n        childNodes = serializeChildNodes(element, childNodesSerializationOptions);\n    }\n    return {\n        type: NodeType.Element,\n        tagName,\n        attributes,\n        childNodes,\n        isSVG,\n    };\n}\nfunction isSVGElement(el) {\n    return el.tagName === 'svg' || el instanceof SVGElement;\n}\n/**\n * Text Nodes are dependant on Element nodes\n * Privacy levels are set on elements so we check the parentElement of a text node\n * for privacy level.\n */\nfunction serializeTextNode(textNode, options) {\n    const textContent = getTextContent(textNode, options.ignoreWhiteSpace || false, options.parentNodePrivacyLevel);\n    if (textContent === undefined) {\n        return;\n    }\n    return {\n        type: NodeType.Text,\n        textContent,\n    };\n}\nfunction serializeCDataNode() {\n    return {\n        type: NodeType.CDATA,\n        textContent: '',\n    };\n}\n//# sourceMappingURL=serializeNode.js.map","import { serializeNodeWithId } from './serializeNode';\nexport function serializeDocument(document, configuration, serializationContext) {\n    // We are sure that Documents are never ignored, so this function never returns null\n    return serializeNodeWithId(document, {\n        serializationContext,\n        parentNodePrivacyLevel: configuration.defaultPrivacyLevel,\n        configuration,\n    });\n}\n//# sourceMappingURL=serializeDocument.js.map","import { isNodeShadowHost } from '@datadog/browser-rum-core';\nexport function isTouchEvent(event) {\n    return Boolean(event.changedTouches);\n}\nexport function getEventTarget(event) {\n    if (event.composed === true && isNodeShadowHost(event.target)) {\n        return event.composedPath()[0];\n    }\n    return event.target;\n}\n//# sourceMappingURL=eventsUtils.js.map","/**\n * Browsers have not standardized various dimension properties. Mobile devices typically report\n * dimensions in reference to the visual viewport, while desktop uses the layout viewport. For example,\n * Mobile Chrome will change innerWidth when a pinch zoom takes place, while Chrome Desktop (mac) will not.\n *\n * With the new Viewport API, we now calculate and normalize dimension properties to the layout viewport.\n * If the VisualViewport API is not supported by a browser, it isn't reasonably possible to detect or normalize\n * which viewport is being measured. Therefore these exported functions will fallback to assuming that the layout\n * viewport is being measured by the browser\n */\n// Scrollbar widths vary across properties on different devices and browsers\nconst TOLERANCE = 25;\n/**\n * Use the Visual Viewport API's properties to measure scrollX/Y in reference to the layout viewport\n * in order to determine if window.scrollX/Y is measuring the layout or visual viewport.\n * This finding corresponds to which viewport mouseEvent.clientX/Y and window.innerWidth/Height measures.\n */\nfunction isVisualViewportFactoredIn(visualViewport) {\n    return (Math.abs(visualViewport.pageTop - visualViewport.offsetTop - window.scrollY) > TOLERANCE ||\n        Math.abs(visualViewport.pageLeft - visualViewport.offsetLeft - window.scrollX) > TOLERANCE);\n}\nexport const convertMouseEventToLayoutCoordinates = (clientX, clientY) => {\n    const visualViewport = window.visualViewport;\n    const normalized = {\n        layoutViewportX: clientX,\n        layoutViewportY: clientY,\n        visualViewportX: clientX,\n        visualViewportY: clientY,\n    };\n    if (!visualViewport) {\n        // On old browsers, we cannot normalize, so fallback to clientX/Y\n        return normalized;\n    }\n    else if (isVisualViewportFactoredIn(visualViewport)) {\n        // Typically Mobile Devices\n        normalized.layoutViewportX = Math.round(clientX + visualViewport.offsetLeft);\n        normalized.layoutViewportY = Math.round(clientY + visualViewport.offsetTop);\n    }\n    else {\n        // Typically Desktop Devices\n        normalized.visualViewportX = Math.round(clientX - visualViewport.offsetLeft);\n        normalized.visualViewportY = Math.round(clientY - visualViewport.offsetTop);\n    }\n    return normalized;\n};\nexport const getVisualViewport = (visualViewport) => ({\n    scale: visualViewport.scale,\n    offsetLeft: visualViewport.offsetLeft,\n    offsetTop: visualViewport.offsetTop,\n    pageLeft: visualViewport.pageLeft,\n    pageTop: visualViewport.pageTop,\n    height: visualViewport.height,\n    width: visualViewport.width,\n});\n//# sourceMappingURL=viewports.js.map","import { timeStampNow } from '@datadog/browser-core';\nimport { RecordType } from '../../types';\nexport function assembleIncrementalSnapshot(source, data) {\n    return {\n        data: {\n            source,\n            ...data,\n        },\n        type: RecordType.IncrementalSnapshot,\n        timestamp: timeStampNow(),\n    };\n}\n//# sourceMappingURL=assembly.js.map","import { addEventListeners, addTelemetryDebug, throttle } from '@datadog/browser-core';\nimport { getSerializedNodeId, hasSerializedNode } from '../serialization';\nimport { IncrementalSource } from '../../../types';\nimport { getEventTarget, isTouchEvent } from '../eventsUtils';\nimport { convertMouseEventToLayoutCoordinates } from '../viewports';\nimport { assembleIncrementalSnapshot } from '../assembly';\nconst MOUSE_MOVE_OBSERVER_THRESHOLD = 50;\nexport function trackMove(configuration, moveCb) {\n    const { throttled: updatePosition, cancel: cancelThrottle } = throttle((event) => {\n        const target = getEventTarget(event);\n        if (hasSerializedNode(target)) {\n            const coordinates = tryToComputeCoordinates(event);\n            if (!coordinates) {\n                return;\n            }\n            const position = {\n                id: getSerializedNodeId(target),\n                timeOffset: 0,\n                x: coordinates.x,\n                y: coordinates.y,\n            };\n            moveCb(assembleIncrementalSnapshot(isTouchEvent(event) ? IncrementalSource.TouchMove : IncrementalSource.MouseMove, { positions: [position] }));\n        }\n    }, MOUSE_MOVE_OBSERVER_THRESHOLD, {\n        trailing: false,\n    });\n    const { stop: removeListener } = addEventListeners(configuration, document, [\"mousemove\" /* DOM_EVENT.MOUSE_MOVE */, \"touchmove\" /* DOM_EVENT.TOUCH_MOVE */], updatePosition, {\n        capture: true,\n        passive: true,\n    });\n    return {\n        stop: () => {\n            removeListener();\n            cancelThrottle();\n        },\n    };\n}\nexport function tryToComputeCoordinates(event) {\n    let { clientX: x, clientY: y } = isTouchEvent(event) ? event.changedTouches[0] : event;\n    if (window.visualViewport) {\n        const { visualViewportX, visualViewportY } = convertMouseEventToLayoutCoordinates(x, y);\n        x = visualViewportX;\n        y = visualViewportY;\n    }\n    if (!Number.isFinite(x) || !Number.isFinite(y)) {\n        if (event.isTrusted) {\n            addTelemetryDebug('mouse/touch event without x/y');\n        }\n        return undefined;\n    }\n    return { x, y };\n}\n//# sourceMappingURL=trackMove.js.map","import { addEventListeners } from '@datadog/browser-core';\nimport { getNodePrivacyLevel, NodePrivacyLevel } from '@datadog/browser-rum-core';\nimport { IncrementalSource, MouseInteractionType } from '../../../types';\nimport { assembleIncrementalSnapshot } from '../assembly';\nimport { getEventTarget } from '../eventsUtils';\nimport { getSerializedNodeId, hasSerializedNode } from '../serialization';\nimport { tryToComputeCoordinates } from './trackMove';\nconst eventTypeToMouseInteraction = {\n    // Listen for pointerup DOM events instead of mouseup for MouseInteraction/MouseUp records. This\n    // allows to reference such records from Frustration records.\n    //\n    // In the context of supporting Mobile Session Replay, we introduced `PointerInteraction` records\n    // used by the Mobile SDKs in place of `MouseInteraction`. In the future, we should replace\n    // `MouseInteraction` by `PointerInteraction` in the Browser SDK so we have an uniform way to\n    // convey such interaction. This would cleanly solve the issue since we would have\n    // `PointerInteraction/Up` records that we could reference from `Frustration` records.\n    [\"pointerup\" /* DOM_EVENT.POINTER_UP */]: MouseInteractionType.MouseUp,\n    [\"mousedown\" /* DOM_EVENT.MOUSE_DOWN */]: MouseInteractionType.MouseDown,\n    [\"click\" /* DOM_EVENT.CLICK */]: MouseInteractionType.Click,\n    [\"contextmenu\" /* DOM_EVENT.CONTEXT_MENU */]: MouseInteractionType.ContextMenu,\n    [\"dblclick\" /* DOM_EVENT.DBL_CLICK */]: MouseInteractionType.DblClick,\n    [\"focus\" /* DOM_EVENT.FOCUS */]: MouseInteractionType.Focus,\n    [\"blur\" /* DOM_EVENT.BLUR */]: MouseInteractionType.Blur,\n    [\"touchstart\" /* DOM_EVENT.TOUCH_START */]: MouseInteractionType.TouchStart,\n    [\"touchend\" /* DOM_EVENT.TOUCH_END */]: MouseInteractionType.TouchEnd,\n};\nexport function trackMouseInteraction(configuration, mouseInteractionCb, recordIds) {\n    const handler = (event) => {\n        const target = getEventTarget(event);\n        if (getNodePrivacyLevel(target, configuration.defaultPrivacyLevel) === NodePrivacyLevel.HIDDEN ||\n            !hasSerializedNode(target)) {\n            return;\n        }\n        const id = getSerializedNodeId(target);\n        const type = eventTypeToMouseInteraction[event.type];\n        let interaction;\n        if (type !== MouseInteractionType.Blur && type !== MouseInteractionType.Focus) {\n            const coordinates = tryToComputeCoordinates(event);\n            if (!coordinates) {\n                return;\n            }\n            interaction = { id, type, x: coordinates.x, y: coordinates.y };\n        }\n        else {\n            interaction = { id, type };\n        }\n        const record = {\n            id: recordIds.getIdForEvent(event),\n            ...assembleIncrementalSnapshot(IncrementalSource.MouseInteraction, interaction),\n        };\n        mouseInteractionCb(record);\n    };\n    return addEventListeners(configuration, document, Object.keys(eventTypeToMouseInteraction), handler, {\n        capture: true,\n        passive: true,\n    });\n}\n//# sourceMappingURL=trackMouseInteraction.js.map","import { throttle, addEventListener } from '@datadog/browser-core';\nimport { getScrollX, getScrollY, getNodePrivacyLevel, NodePrivacyLevel } from '@datadog/browser-rum-core';\nimport { getEventTarget } from '../eventsUtils';\nimport { getSerializedNodeId, hasSerializedNode } from '../serialization';\nimport { IncrementalSource } from '../../../types';\nimport { assembleIncrementalSnapshot } from '../assembly';\nconst SCROLL_OBSERVER_THRESHOLD = 100;\nexport function trackScroll(configuration, scrollCb, elementsScrollPositions, target = document) {\n    const { throttled: updatePosition, cancel: cancelThrottle } = throttle((event) => {\n        const target = getEventTarget(event);\n        if (!target ||\n            getNodePrivacyLevel(target, configuration.defaultPrivacyLevel) === NodePrivacyLevel.HIDDEN ||\n            !hasSerializedNode(target)) {\n            return;\n        }\n        const id = getSerializedNodeId(target);\n        const scrollPositions = target === document\n            ? {\n                scrollTop: getScrollY(),\n                scrollLeft: getScrollX(),\n            }\n            : {\n                scrollTop: Math.round(target.scrollTop),\n                scrollLeft: Math.round(target.scrollLeft),\n            };\n        elementsScrollPositions.set(target, scrollPositions);\n        scrollCb(assembleIncrementalSnapshot(IncrementalSource.Scroll, {\n            id,\n            x: scrollPositions.scrollLeft,\n            y: scrollPositions.scrollTop,\n        }));\n    }, SCROLL_OBSERVER_THRESHOLD);\n    const { stop: removeListener } = addEventListener(configuration, target, \"scroll\" /* DOM_EVENT.SCROLL */, updatePosition, {\n        capture: true,\n        passive: true,\n    });\n    return {\n        stop: () => {\n            removeListener();\n            cancelThrottle();\n        },\n    };\n}\n//# sourceMappingURL=trackScroll.js.map","import { throttle, addEventListeners, timeStampNow, noop } from '@datadog/browser-core';\nimport { initViewportObservable } from '@datadog/browser-rum-core';\nimport { IncrementalSource, RecordType } from '../../../types';\nimport { getVisualViewport } from '../viewports';\nimport { assembleIncrementalSnapshot } from '../assembly';\nconst VISUAL_VIEWPORT_OBSERVER_THRESHOLD = 200;\nexport function trackViewportResize(configuration, viewportResizeCb) {\n    const viewportResizeSubscription = initViewportObservable(configuration).subscribe((data) => {\n        viewportResizeCb(assembleIncrementalSnapshot(IncrementalSource.ViewportResize, data));\n    });\n    return {\n        stop: () => {\n            viewportResizeSubscription.unsubscribe();\n        },\n    };\n}\nexport function trackVisualViewportResize(configuration, visualViewportResizeCb) {\n    const visualViewport = window.visualViewport;\n    if (!visualViewport) {\n        return { stop: noop };\n    }\n    const { throttled: updateDimension, cancel: cancelThrottle } = throttle(() => {\n        visualViewportResizeCb({\n            data: getVisualViewport(visualViewport),\n            type: RecordType.VisualViewport,\n            timestamp: timeStampNow(),\n        });\n    }, VISUAL_VIEWPORT_OBSERVER_THRESHOLD, {\n        trailing: false,\n    });\n    const { stop: removeListener } = addEventListeners(configuration, visualViewport, [\"resize\" /* DOM_EVENT.RESIZE */, \"scroll\" /* DOM_EVENT.SCROLL */], updateDimension, {\n        capture: true,\n        passive: true,\n    });\n    return {\n        stop: () => {\n            removeListener();\n            cancelThrottle();\n        },\n    };\n}\n//# sourceMappingURL=trackViewportResize.js.map","import { addEventListeners } from '@datadog/browser-core';\nimport { NodePrivacyLevel, getNodePrivacyLevel } from '@datadog/browser-rum-core';\nimport { IncrementalSource, MediaInteractionType } from '../../../types';\nimport { getEventTarget } from '../eventsUtils';\nimport { getSerializedNodeId, hasSerializedNode } from '../serialization';\nimport { assembleIncrementalSnapshot } from '../assembly';\nexport function trackMediaInteraction(configuration, mediaInteractionCb) {\n    return addEventListeners(configuration, document, [\"play\" /* DOM_EVENT.PLAY */, \"pause\" /* DOM_EVENT.PAUSE */], (event) => {\n        const target = getEventTarget(event);\n        if (!target ||\n            getNodePrivacyLevel(target, configuration.defaultPrivacyLevel) === NodePrivacyLevel.HIDDEN ||\n            !hasSerializedNode(target)) {\n            return;\n        }\n        mediaInteractionCb(assembleIncrementalSnapshot(IncrementalSource.MediaInteraction, {\n            id: getSerializedNodeId(target),\n            type: event.type === \"play\" /* DOM_EVENT.PLAY */ ? MediaInteractionType.Play : MediaInteractionType.Pause,\n        }));\n    }, {\n        capture: true,\n        passive: true,\n    });\n}\n//# sourceMappingURL=trackMediaInteraction.js.map","import { instrumentMethod } from '@datadog/browser-core';\nimport { IncrementalSource } from '../../../types';\nimport { getSerializedNodeId, hasSerializedNode } from '../serialization';\nimport { assembleIncrementalSnapshot } from '../assembly';\nexport function trackStyleSheet(styleSheetCb) {\n    function checkStyleSheetAndCallback(styleSheet, callback) {\n        if (styleSheet && hasSerializedNode(styleSheet.ownerNode)) {\n            callback(getSerializedNodeId(styleSheet.ownerNode));\n        }\n    }\n    const instrumentationStoppers = [\n        instrumentMethod(CSSStyleSheet.prototype, 'insertRule', ({ target: styleSheet, parameters: [rule, index] }) => {\n            checkStyleSheetAndCallback(styleSheet, (id) => styleSheetCb(assembleIncrementalSnapshot(IncrementalSource.StyleSheetRule, {\n                id,\n                adds: [{ rule, index }],\n            })));\n        }),\n        instrumentMethod(CSSStyleSheet.prototype, 'deleteRule', ({ target: styleSheet, parameters: [index] }) => {\n            checkStyleSheetAndCallback(styleSheet, (id) => styleSheetCb(assembleIncrementalSnapshot(IncrementalSource.StyleSheetRule, {\n                id,\n                removes: [{ index }],\n            })));\n        }),\n    ];\n    if (typeof CSSGroupingRule !== 'undefined') {\n        instrumentGroupingCSSRuleClass(CSSGroupingRule);\n    }\n    else {\n        instrumentGroupingCSSRuleClass(CSSMediaRule);\n        instrumentGroupingCSSRuleClass(CSSSupportsRule);\n    }\n    function instrumentGroupingCSSRuleClass(cls) {\n        instrumentationStoppers.push(instrumentMethod(cls.prototype, 'insertRule', ({ target: styleSheet, parameters: [rule, index] }) => {\n            checkStyleSheetAndCallback(styleSheet.parentStyleSheet, (id) => {\n                const path = getPathToNestedCSSRule(styleSheet);\n                if (path) {\n                    path.push(index || 0);\n                    styleSheetCb(assembleIncrementalSnapshot(IncrementalSource.StyleSheetRule, {\n                        id,\n                        adds: [{ rule, index: path }],\n                    }));\n                }\n            });\n        }), instrumentMethod(cls.prototype, 'deleteRule', ({ target: styleSheet, parameters: [index] }) => {\n            checkStyleSheetAndCallback(styleSheet.parentStyleSheet, (id) => {\n                const path = getPathToNestedCSSRule(styleSheet);\n                if (path) {\n                    path.push(index);\n                    styleSheetCb(assembleIncrementalSnapshot(IncrementalSource.StyleSheetRule, {\n                        id,\n                        removes: [{ index: path }],\n                    }));\n                }\n            });\n        }));\n    }\n    return {\n        stop: () => {\n            instrumentationStoppers.forEach((stopper) => stopper.stop());\n        },\n    };\n}\nexport function getPathToNestedCSSRule(rule) {\n    const path = [];\n    let currentRule = rule;\n    while (currentRule.parentRule) {\n        const rules = Array.from(currentRule.parentRule.cssRules);\n        const index = rules.indexOf(currentRule);\n        path.unshift(index);\n        currentRule = currentRule.parentRule;\n    }\n    // A rule may not be attached to a stylesheet\n    if (!currentRule.parentStyleSheet) {\n        return;\n    }\n    const rules = Array.from(currentRule.parentStyleSheet.cssRules);\n    const index = rules.indexOf(currentRule);\n    path.unshift(index);\n    return path;\n}\n//# sourceMappingURL=trackStyleSheet.js.map","import { addEventListeners, timeStampNow } from '@datadog/browser-core';\nimport { RecordType } from '../../../types';\nexport function trackFocus(configuration, focusCb) {\n    return addEventListeners(configuration, window, [\"focus\" /* DOM_EVENT.FOCUS */, \"blur\" /* DOM_EVENT.BLUR */], () => {\n        focusCb({\n            data: { has_focus: document.hasFocus() },\n            type: RecordType.Focus,\n            timestamp: timeStampNow(),\n        });\n    });\n}\n//# sourceMappingURL=trackFocus.js.map","import { RecordType } from '../../../types';\nexport function trackFrustration(lifeCycle, frustrationCb, recordIds) {\n    const frustrationSubscription = lifeCycle.subscribe(12 /* LifeCycleEventType.RAW_RUM_EVENT_COLLECTED */, (data) => {\n        var _a, _b;\n        if (data.rawRumEvent.type === \"action\" /* RumEventType.ACTION */ &&\n            data.rawRumEvent.action.type === \"click\" /* ActionType.CLICK */ &&\n            ((_b = (_a = data.rawRumEvent.action.frustration) === null || _a === void 0 ? void 0 : _a.type) === null || _b === void 0 ? void 0 : _b.length) &&\n            'events' in data.domainContext &&\n            data.domainContext.events &&\n            data.domainContext.events.length) {\n            frustrationCb({\n                timestamp: data.rawRumEvent.date,\n                type: RecordType.FrustrationRecord,\n                data: {\n                    frustrationTypes: data.rawRumEvent.action.frustration.type,\n                    recordIds: data.domainContext.events.map((e) => recordIds.getIdForEvent(e)),\n                },\n            });\n        }\n    });\n    return {\n        stop: () => {\n            frustrationSubscription.unsubscribe();\n        },\n    };\n}\n//# sourceMappingURL=trackFrustration.js.map","import { timeStampNow } from '@datadog/browser-core';\nimport { RecordType } from '../../../types';\nexport function trackViewEnd(lifeCycle, viewEndCb) {\n    const viewEndSubscription = lifeCycle.subscribe(5 /* LifeCycleEventType.VIEW_ENDED */, () => {\n        viewEndCb({\n            timestamp: timeStampNow(),\n            type: RecordType.ViewEnd,\n        });\n    });\n    return {\n        stop: () => {\n            viewEndSubscription.unsubscribe();\n        },\n    };\n}\n//# sourceMappingURL=trackViewEnd.js.map","import { instrumentSetter, addEventListeners, noop } from '@datadog/browser-core';\nimport { NodePrivacyLevel, getNodePrivacyLevel, shouldMaskNode } from '@datadog/browser-rum-core';\nimport { IncrementalSource } from '../../../types';\nimport { getEventTarget } from '../eventsUtils';\nimport { getElementInputValue, getSerializedNodeId, hasSerializedNode } from '../serialization';\nimport { assembleIncrementalSnapshot } from '../assembly';\nexport function trackInput(configuration, inputCb, target = document) {\n    const defaultPrivacyLevel = configuration.defaultPrivacyLevel;\n    const lastInputStateMap = new WeakMap();\n    const isShadowRoot = target !== document;\n    const { stop: stopEventListeners } = addEventListeners(configuration, target, \n    // The 'input' event bubbles across shadow roots, so we don't have to listen for it on shadow\n    // roots since it will be handled by the event listener that we did add to the document. Only\n    // the 'change' event is blocked and needs to be handled on shadow roots.\n    isShadowRoot ? [\"change\" /* DOM_EVENT.CHANGE */] : [\"input\" /* DOM_EVENT.INPUT */, \"change\" /* DOM_EVENT.CHANGE */], (event) => {\n        const target = getEventTarget(event);\n        if (target instanceof HTMLInputElement ||\n            target instanceof HTMLTextAreaElement ||\n            target instanceof HTMLSelectElement) {\n            onElementChange(target);\n        }\n    }, {\n        capture: true,\n        passive: true,\n    });\n    let stopPropertySetterInstrumentation;\n    if (!isShadowRoot) {\n        const instrumentationStoppers = [\n            instrumentSetter(HTMLInputElement.prototype, 'value', onElementChange),\n            instrumentSetter(HTMLInputElement.prototype, 'checked', onElementChange),\n            instrumentSetter(HTMLSelectElement.prototype, 'value', onElementChange),\n            instrumentSetter(HTMLTextAreaElement.prototype, 'value', onElementChange),\n            instrumentSetter(HTMLSelectElement.prototype, 'selectedIndex', onElementChange),\n        ];\n        stopPropertySetterInstrumentation = () => {\n            instrumentationStoppers.forEach((stopper) => stopper.stop());\n        };\n    }\n    else {\n        stopPropertySetterInstrumentation = noop;\n    }\n    return {\n        stop: () => {\n            stopPropertySetterInstrumentation();\n            stopEventListeners();\n        },\n    };\n    function onElementChange(target) {\n        const nodePrivacyLevel = getNodePrivacyLevel(target, defaultPrivacyLevel);\n        if (nodePrivacyLevel === NodePrivacyLevel.HIDDEN) {\n            return;\n        }\n        const type = target.type;\n        let inputState;\n        if (type === 'radio' || type === 'checkbox') {\n            if (shouldMaskNode(target, nodePrivacyLevel)) {\n                return;\n            }\n            inputState = { isChecked: target.checked };\n        }\n        else {\n            const value = getElementInputValue(target, nodePrivacyLevel);\n            if (value === undefined) {\n                return;\n            }\n            inputState = { text: value };\n        }\n        // Can be multiple changes on the same node within the same batched mutation observation.\n        cbWithDedup(target, inputState);\n        // If a radio was checked, other radios with the same name attribute will be unchecked.\n        const name = target.name;\n        if (type === 'radio' && name && target.checked) {\n            document.querySelectorAll(`input[type=\"radio\"][name=\"${CSS.escape(name)}\"]`).forEach((el) => {\n                if (el !== target) {\n                    // TODO: Consider the privacy implications for various differing input privacy levels\n                    cbWithDedup(el, { isChecked: false });\n                }\n            });\n        }\n    }\n    /**\n     * There can be multiple changes on the same node within the same batched mutation observation.\n     */\n    function cbWithDedup(target, inputState) {\n        if (!hasSerializedNode(target)) {\n            return;\n        }\n        const lastInputState = lastInputStateMap.get(target);\n        if (!lastInputState ||\n            lastInputState.text !== inputState.text ||\n            lastInputState.isChecked !== inputState.isChecked) {\n            lastInputStateMap.set(target, inputState);\n            inputCb(assembleIncrementalSnapshot(IncrementalSource.Input, {\n                id: getSerializedNodeId(target),\n                ...inputState,\n            }));\n        }\n    }\n}\n//# sourceMappingURL=trackInput.js.map","import { noop, throttle, requestIdleCallback } from '@datadog/browser-core';\n/**\n * Maximum duration to wait before processing mutations. If the browser is idle, mutations will be\n * processed more quickly. If the browser is busy executing small tasks (ex: rendering frames), the\n * mutations will wait MUTATION_PROCESS_MAX_DELAY milliseconds before being processed. If the\n * browser is busy executing a longer task, mutations will be processed after this task.\n */\nconst MUTATION_PROCESS_MAX_DELAY = 100;\n/**\n * Minimum duration to wait before processing mutations. This is used to batch mutations together\n * and be able to deduplicate them to save processing time and bandwidth.\n * 16ms is the duration of a frame at 60fps that ensure fluid UI.\n */\nexport const MUTATION_PROCESS_MIN_DELAY = 16;\nexport function createMutationBatch(processMutationBatch) {\n    let cancelScheduledFlush = noop;\n    let pendingMutations = [];\n    function flush() {\n        cancelScheduledFlush();\n        processMutationBatch(pendingMutations);\n        pendingMutations = [];\n    }\n    const { throttled: throttledFlush, cancel: cancelThrottle } = throttle(flush, MUTATION_PROCESS_MIN_DELAY, {\n        leading: false,\n    });\n    return {\n        addMutations: (mutations) => {\n            if (pendingMutations.length === 0) {\n                cancelScheduledFlush = requestIdleCallback(throttledFlush, { timeout: MUTATION_PROCESS_MAX_DELAY });\n            }\n            pendingMutations.push(...mutations);\n        },\n        flush,\n        stop: () => {\n            cancelScheduledFlush();\n            cancelThrottle();\n        },\n    };\n}\n//# sourceMappingURL=mutationBatch.js.map","import { monitor, noop } from '@datadog/browser-core';\nimport { isNodeShadowHost, getMutationObserverConstructor, getParentNode, forEachChildNodes, getNodePrivacyLevel, getTextContent, NodePrivacyLevel, } from '@datadog/browser-rum-core';\nimport { IncrementalSource } from '../../../types';\nimport { getElementInputValue, getSerializedNodeId, hasSerializedNode, nodeAndAncestorsHaveSerializedNode, serializeNodeWithId, serializeAttribute, } from '../serialization';\nimport { createMutationBatch } from '../mutationBatch';\nimport { assembleIncrementalSnapshot } from '../assembly';\n/**\n * Buffers and aggregate mutations generated by a MutationObserver into MutationPayload\n */\nexport function trackMutation(mutationCallback, configuration, shadowRootsController, target) {\n    const MutationObserver = getMutationObserverConstructor();\n    if (!MutationObserver) {\n        return { stop: noop, flush: noop };\n    }\n    const mutationBatch = createMutationBatch((mutations) => {\n        processMutations(mutations.concat(observer.takeRecords()), mutationCallback, configuration, shadowRootsController);\n    });\n    const observer = new MutationObserver(monitor(mutationBatch.addMutations));\n    observer.observe(target, {\n        attributeOldValue: true,\n        attributes: true,\n        characterData: true,\n        characterDataOldValue: true,\n        childList: true,\n        subtree: true,\n    });\n    return {\n        stop: () => {\n            observer.disconnect();\n            mutationBatch.stop();\n        },\n        flush: () => {\n            mutationBatch.flush();\n        },\n    };\n}\nfunction processMutations(mutations, mutationCallback, configuration, shadowRootsController) {\n    const nodePrivacyLevelCache = new Map();\n    mutations\n        .filter((mutation) => mutation.type === 'childList')\n        .forEach((mutation) => {\n        mutation.removedNodes.forEach((removedNode) => {\n            traverseRemovedShadowDom(removedNode, shadowRootsController.removeShadowRoot);\n        });\n    });\n    // Discard any mutation with a 'target' node that:\n    // * isn't injected in the current document or isn't known/serialized yet: those nodes are likely\n    // part of a mutation occurring in a parent Node\n    // * should be hidden or ignored\n    const filteredMutations = mutations.filter((mutation) => mutation.target.isConnected &&\n        nodeAndAncestorsHaveSerializedNode(mutation.target) &&\n        getNodePrivacyLevel(mutation.target, configuration.defaultPrivacyLevel, nodePrivacyLevelCache) !==\n            NodePrivacyLevel.HIDDEN);\n    const { adds, removes, hasBeenSerialized } = processChildListMutations(filteredMutations.filter((mutation) => mutation.type === 'childList'), configuration, shadowRootsController, nodePrivacyLevelCache);\n    const texts = processCharacterDataMutations(filteredMutations.filter((mutation) => mutation.type === 'characterData' && !hasBeenSerialized(mutation.target)), configuration, nodePrivacyLevelCache);\n    const attributes = processAttributesMutations(filteredMutations.filter((mutation) => mutation.type === 'attributes' && !hasBeenSerialized(mutation.target)), configuration, nodePrivacyLevelCache);\n    if (!texts.length && !attributes.length && !removes.length && !adds.length) {\n        return;\n    }\n    mutationCallback(assembleIncrementalSnapshot(IncrementalSource.Mutation, { adds, removes, texts, attributes }));\n}\nfunction processChildListMutations(mutations, configuration, shadowRootsController, nodePrivacyLevelCache) {\n    // First, we iterate over mutations to collect:\n    //\n    // * nodes that have been added in the document and not removed by a subsequent mutation\n    // * nodes that have been removed from the document but were not added in a previous mutation\n    //\n    // For this second category, we also collect their previous parent (mutation.target) because we'll\n    // need it to emit a 'remove' mutation.\n    //\n    // Those two categories may overlap: if a node moved from a position to another, it is reported as\n    // two mutation records, one with a \"removedNodes\" and the other with \"addedNodes\". In this case,\n    // the node will be in both sets.\n    const addedAndMovedNodes = new Set();\n    const removedNodes = new Map();\n    for (const mutation of mutations) {\n        mutation.addedNodes.forEach((node) => {\n            addedAndMovedNodes.add(node);\n        });\n        mutation.removedNodes.forEach((node) => {\n            if (!addedAndMovedNodes.has(node)) {\n                removedNodes.set(node, mutation.target);\n            }\n            addedAndMovedNodes.delete(node);\n        });\n    }\n    // Then, we sort nodes that are still in the document by topological order, for two reasons:\n    //\n    // * We will serialize each added nodes with their descendants. We don't want to serialize a node\n    // twice, so we need to iterate over the parent nodes first and skip any node that is contained in\n    // a precedent node.\n    //\n    // * To emit \"add\" mutations, we need references to the parent and potential next sibling of each\n    // added node. So we need to iterate over the parent nodes first, and when multiple nodes are\n    // siblings, we want to iterate from last to first. This will ensure that any \"next\" node is\n    // already serialized and have an id.\n    const sortedAddedAndMovedNodes = Array.from(addedAndMovedNodes);\n    sortAddedAndMovedNodes(sortedAddedAndMovedNodes);\n    // Then, we iterate over our sorted node sets to emit mutations. We collect the newly serialized\n    // node ids in a set to be able to skip subsequent related mutations.\n    const serializedNodeIds = new Set();\n    const addedNodeMutations = [];\n    for (const node of sortedAddedAndMovedNodes) {\n        if (hasBeenSerialized(node)) {\n            continue;\n        }\n        const parentNodePrivacyLevel = getNodePrivacyLevel(node.parentNode, configuration.defaultPrivacyLevel, nodePrivacyLevelCache);\n        if (parentNodePrivacyLevel === NodePrivacyLevel.HIDDEN || parentNodePrivacyLevel === NodePrivacyLevel.IGNORE) {\n            continue;\n        }\n        const serializedNode = serializeNodeWithId(node, {\n            serializedNodeIds,\n            parentNodePrivacyLevel,\n            serializationContext: { status: 2 /* SerializationContextStatus.MUTATION */, shadowRootsController },\n            configuration,\n        });\n        if (!serializedNode) {\n            continue;\n        }\n        const parentNode = getParentNode(node);\n        addedNodeMutations.push({\n            nextId: getNextSibling(node),\n            parentId: getSerializedNodeId(parentNode),\n            node: serializedNode,\n        });\n    }\n    // Finally, we emit remove mutations.\n    const removedNodeMutations = [];\n    removedNodes.forEach((parent, node) => {\n        if (hasSerializedNode(node)) {\n            removedNodeMutations.push({\n                parentId: getSerializedNodeId(parent),\n                id: getSerializedNodeId(node),\n            });\n        }\n    });\n    return { adds: addedNodeMutations, removes: removedNodeMutations, hasBeenSerialized };\n    function hasBeenSerialized(node) {\n        return hasSerializedNode(node) && serializedNodeIds.has(getSerializedNodeId(node));\n    }\n    function getNextSibling(node) {\n        let nextSibling = node.nextSibling;\n        while (nextSibling) {\n            if (hasSerializedNode(nextSibling)) {\n                return getSerializedNodeId(nextSibling);\n            }\n            nextSibling = nextSibling.nextSibling;\n        }\n        return null;\n    }\n}\nfunction processCharacterDataMutations(mutations, configuration, nodePrivacyLevelCache) {\n    var _a;\n    const textMutations = [];\n    // Deduplicate mutations based on their target node\n    const handledNodes = new Set();\n    const filteredMutations = mutations.filter((mutation) => {\n        if (handledNodes.has(mutation.target)) {\n            return false;\n        }\n        handledNodes.add(mutation.target);\n        return true;\n    });\n    // Emit mutations\n    for (const mutation of filteredMutations) {\n        const value = mutation.target.textContent;\n        if (value === mutation.oldValue) {\n            continue;\n        }\n        const parentNodePrivacyLevel = getNodePrivacyLevel(getParentNode(mutation.target), configuration.defaultPrivacyLevel, nodePrivacyLevelCache);\n        if (parentNodePrivacyLevel === NodePrivacyLevel.HIDDEN || parentNodePrivacyLevel === NodePrivacyLevel.IGNORE) {\n            continue;\n        }\n        textMutations.push({\n            id: getSerializedNodeId(mutation.target),\n            // TODO: pass a valid \"ignoreWhiteSpace\" argument\n            value: (_a = getTextContent(mutation.target, false, parentNodePrivacyLevel)) !== null && _a !== void 0 ? _a : null,\n        });\n    }\n    return textMutations;\n}\nfunction processAttributesMutations(mutations, configuration, nodePrivacyLevelCache) {\n    const attributeMutations = [];\n    // Deduplicate mutations based on their target node and changed attribute\n    const handledElements = new Map();\n    const filteredMutations = mutations.filter((mutation) => {\n        const handledAttributes = handledElements.get(mutation.target);\n        if (handledAttributes && handledAttributes.has(mutation.attributeName)) {\n            return false;\n        }\n        if (!handledAttributes) {\n            handledElements.set(mutation.target, new Set([mutation.attributeName]));\n        }\n        else {\n            handledAttributes.add(mutation.attributeName);\n        }\n        return true;\n    });\n    // Emit mutations\n    const emittedMutations = new Map();\n    for (const mutation of filteredMutations) {\n        const uncensoredValue = mutation.target.getAttribute(mutation.attributeName);\n        if (uncensoredValue === mutation.oldValue) {\n            continue;\n        }\n        const privacyLevel = getNodePrivacyLevel(mutation.target, configuration.defaultPrivacyLevel, nodePrivacyLevelCache);\n        const attributeValue = serializeAttribute(mutation.target, privacyLevel, mutation.attributeName, configuration);\n        let transformedValue;\n        if (mutation.attributeName === 'value') {\n            const inputValue = getElementInputValue(mutation.target, privacyLevel);\n            if (inputValue === undefined) {\n                continue;\n            }\n            transformedValue = inputValue;\n        }\n        else if (typeof attributeValue === 'string') {\n            transformedValue = attributeValue;\n        }\n        else {\n            transformedValue = null;\n        }\n        let emittedMutation = emittedMutations.get(mutation.target);\n        if (!emittedMutation) {\n            emittedMutation = {\n                id: getSerializedNodeId(mutation.target),\n                attributes: {},\n            };\n            attributeMutations.push(emittedMutation);\n            emittedMutations.set(mutation.target, emittedMutation);\n        }\n        emittedMutation.attributes[mutation.attributeName] = transformedValue;\n    }\n    return attributeMutations;\n}\nexport function sortAddedAndMovedNodes(nodes) {\n    nodes.sort((a, b) => {\n        const position = a.compareDocumentPosition(b);\n        /* eslint-disable no-bitwise */\n        if (position & Node.DOCUMENT_POSITION_CONTAINED_BY) {\n            return -1;\n        }\n        else if (position & Node.DOCUMENT_POSITION_CONTAINS) {\n            return 1;\n        }\n        else if (position & Node.DOCUMENT_POSITION_FOLLOWING) {\n            return 1;\n        }\n        else if (position & Node.DOCUMENT_POSITION_PRECEDING) {\n            return -1;\n        }\n        /* eslint-enable no-bitwise */\n        return 0;\n    });\n}\nfunction traverseRemovedShadowDom(removedNode, shadowDomRemovedCallback) {\n    if (isNodeShadowHost(removedNode)) {\n        shadowDomRemovedCallback(removedNode.shadowRoot);\n    }\n    forEachChildNodes(removedNode, (childNode) => traverseRemovedShadowDom(childNode, shadowDomRemovedCallback));\n}\n//# sourceMappingURL=trackMutation.js.map","export function createElementsScrollPositions() {\n    const scrollPositionsByElement = new WeakMap();\n    return {\n        set(element, scrollPositions) {\n            if (element === document && !document.scrollingElement) {\n                // cf https://drafts.csswg.org/cssom-view/#dom-document-scrollingelement,\n                // in some cases scrolling elements can not be defined, we don't support those for now\n                return;\n            }\n            scrollPositionsByElement.set(element === document ? document.scrollingElement : element, scrollPositions);\n        },\n        get(element) {\n            return scrollPositionsByElement.get(element);\n        },\n        has(element) {\n            return scrollPositionsByElement.has(element);\n        },\n    };\n}\n//# sourceMappingURL=elementsScrollPositions.js.map","import { trackInput, trackMutation, trackScroll } from './trackers';\nexport const initShadowRootsController = (configuration, callback, elementsScrollPositions) => {\n    const controllerByShadowRoot = new Map();\n    const shadowRootsController = {\n        addShadowRoot: (shadowRoot) => {\n            if (controllerByShadowRoot.has(shadowRoot)) {\n                return;\n            }\n            const mutationTracker = trackMutation(callback, configuration, shadowRootsController, shadowRoot);\n            // The change event does not bubble up across the shadow root, we have to listen on the shadow root\n            const inputTracker = trackInput(configuration, callback, shadowRoot);\n            // The scroll event does not bubble up across the shadow root, we have to listen on the shadow root\n            const scrollTracker = trackScroll(configuration, callback, elementsScrollPositions, shadowRoot);\n            controllerByShadowRoot.set(shadowRoot, {\n                flush: () => mutationTracker.flush(),\n                stop: () => {\n                    mutationTracker.stop();\n                    inputTracker.stop();\n                    scrollTracker.stop();\n                },\n            });\n        },\n        removeShadowRoot: (shadowRoot) => {\n            const entry = controllerByShadowRoot.get(shadowRoot);\n            if (!entry) {\n                // unidentified root cause: observed in some cases with shadow DOM added by browser extensions\n                return;\n            }\n            entry.stop();\n            controllerByShadowRoot.delete(shadowRoot);\n        },\n        stop: () => {\n            controllerByShadowRoot.forEach(({ stop }) => stop());\n        },\n        flush: () => {\n            controllerByShadowRoot.forEach(({ flush }) => flush());\n        },\n    };\n    return shadowRootsController;\n};\n//# sourceMappingURL=shadowRootsController.js.map","import { getScrollX, getScrollY, getViewportDimension } from '@datadog/browser-rum-core';\nimport { timeStampNow } from '@datadog/browser-core';\nimport { RecordType } from '../../types';\nimport { serializeDocument } from './serialization';\nimport { getVisualViewport } from './viewports';\nexport function startFullSnapshots(elementsScrollPositions, shadowRootsController, lifeCycle, configuration, flushMutations, fullSnapshotCallback) {\n    const takeFullSnapshot = (timestamp = timeStampNow(), serializationContext = {\n        status: 0 /* SerializationContextStatus.INITIAL_FULL_SNAPSHOT */,\n        elementsScrollPositions,\n        shadowRootsController,\n    }) => {\n        const { width, height } = getViewportDimension();\n        const records = [\n            {\n                data: {\n                    height,\n                    href: window.location.href,\n                    width,\n                },\n                type: RecordType.Meta,\n                timestamp,\n            },\n            {\n                data: {\n                    has_focus: document.hasFocus(),\n                },\n                type: RecordType.Focus,\n                timestamp,\n            },\n            {\n                data: {\n                    node: serializeDocument(document, configuration, serializationContext),\n                    initialOffset: {\n                        left: getScrollX(),\n                        top: getScrollY(),\n                    },\n                },\n                type: RecordType.FullSnapshot,\n                timestamp,\n            },\n        ];\n        if (window.visualViewport) {\n            records.push({\n                data: getVisualViewport(window.visualViewport),\n                type: RecordType.VisualViewport,\n                timestamp,\n            });\n        }\n        return records;\n    };\n    fullSnapshotCallback(takeFullSnapshot());\n    const { unsubscribe } = lifeCycle.subscribe(2 /* LifeCycleEventType.VIEW_CREATED */, (view) => {\n        flushMutations();\n        fullSnapshotCallback(takeFullSnapshot(view.startClocks.timeStamp, {\n            shadowRootsController,\n            status: 1 /* SerializationContextStatus.SUBSEQUENT_FULL_SNAPSHOT */,\n            elementsScrollPositions,\n        }));\n    });\n    return {\n        stop: unsubscribe,\n    };\n}\n//# sourceMappingURL=startFullSnapshots.js.map","export function initRecordIds() {\n    const recordIds = new WeakMap();\n    let nextId = 1;\n    return {\n        getIdForEvent(event) {\n            if (!recordIds.has(event)) {\n                recordIds.set(event, nextId++);\n            }\n            return recordIds.get(event);\n        },\n    };\n}\n//# sourceMappingURL=recordIds.js.map","import { sendToExtension } from '@datadog/browser-core';\nimport * as replayStats from '../replayStats';\nimport { trackFocus, trackFrustration, trackInput, trackMediaInteraction, trackMouseInteraction, trackMove, trackMutation, trackScroll, trackStyleSheet, trackViewEnd, trackViewportResize, trackVisualViewportResize, } from './trackers';\nimport { createElementsScrollPositions } from './elementsScrollPositions';\nimport { initShadowRootsController } from './shadowRootsController';\nimport { startFullSnapshots } from './startFullSnapshots';\nimport { initRecordIds } from './recordIds';\nexport function record(options) {\n    const { emit, configuration, lifeCycle } = options;\n    // runtime checks for user options\n    if (!emit) {\n        throw new Error('emit function is required');\n    }\n    const emitAndComputeStats = (record) => {\n        emit(record);\n        sendToExtension('record', { record });\n        const view = options.viewHistory.findView();\n        replayStats.addRecord(view.id);\n    };\n    const elementsScrollPositions = createElementsScrollPositions();\n    const shadowRootsController = initShadowRootsController(configuration, emitAndComputeStats, elementsScrollPositions);\n    const { stop: stopFullSnapshots } = startFullSnapshots(elementsScrollPositions, shadowRootsController, lifeCycle, configuration, flushMutations, (records) => records.forEach((record) => emitAndComputeStats(record)));\n    function flushMutations() {\n        shadowRootsController.flush();\n        mutationTracker.flush();\n    }\n    const recordIds = initRecordIds();\n    const mutationTracker = trackMutation(emitAndComputeStats, configuration, shadowRootsController, document);\n    const trackers = [\n        mutationTracker,\n        trackMove(configuration, emitAndComputeStats),\n        trackMouseInteraction(configuration, emitAndComputeStats, recordIds),\n        trackScroll(configuration, emitAndComputeStats, elementsScrollPositions, document),\n        trackViewportResize(configuration, emitAndComputeStats),\n        trackInput(configuration, emitAndComputeStats),\n        trackMediaInteraction(configuration, emitAndComputeStats),\n        trackStyleSheet(emitAndComputeStats),\n        trackFocus(configuration, emitAndComputeStats),\n        trackVisualViewportResize(configuration, emitAndComputeStats),\n        trackFrustration(lifeCycle, emitAndComputeStats, recordIds),\n        trackViewEnd(lifeCycle, (viewEndRecord) => {\n            flushMutations();\n            emitAndComputeStats(viewEndRecord);\n        }),\n    ];\n    return {\n        stop: () => {\n            shadowRootsController.stop();\n            trackers.forEach((tracker) => tracker.stop());\n            stopFullSnapshots();\n        },\n        flushMutations,\n        shadowRootsController,\n    };\n}\n//# sourceMappingURL=record.js.map","export function buildReplayPayload(data, metadata, rawSegmentBytesCount) {\n    const formData = new FormData();\n    formData.append('segment', new Blob([data], {\n        type: 'application/octet-stream',\n    }), `${metadata.session.id}-${metadata.start}`);\n    const metadataAndSegmentSizes = {\n        raw_segment_size: rawSegmentBytesCount,\n        compressed_segment_size: data.byteLength,\n        ...metadata,\n    };\n    const serializedMetadataAndSegmentSizes = JSON.stringify(metadataAndSegmentSizes);\n    formData.append('event', new Blob([serializedMetadataAndSegmentSizes], { type: 'application/json' }));\n    return { data: formData, bytesCount: data.byteLength };\n}\n//# sourceMappingURL=buildReplayPayload.js.map","import { RecordType } from '../../types';\nimport * as replayStats from '../replayStats';\nexport function createSegment({ context, creationReason, encoder, }) {\n    let encodedBytesCount = 0;\n    const viewId = context.view.id;\n    const metadata = {\n        start: Infinity,\n        end: -Infinity,\n        creation_reason: creationReason,\n        records_count: 0,\n        has_full_snapshot: false,\n        index_in_view: replayStats.getSegmentsCount(viewId),\n        source: 'browser',\n        ...context,\n    };\n    replayStats.addSegment(viewId);\n    function addRecord(record, callback) {\n        metadata.start = Math.min(metadata.start, record.timestamp);\n        metadata.end = Math.max(metadata.end, record.timestamp);\n        metadata.records_count += 1;\n        metadata.has_full_snapshot || (metadata.has_full_snapshot = record.type === RecordType.FullSnapshot);\n        const prefix = encoder.isEmpty ? '{\"records\":[' : ',';\n        encoder.write(prefix + JSON.stringify(record), (additionalEncodedBytesCount) => {\n            encodedBytesCount += additionalEncodedBytesCount;\n            callback(encodedBytesCount);\n        });\n    }\n    function flush(callback) {\n        if (encoder.isEmpty) {\n            throw new Error('Empty segment flushed');\n        }\n        encoder.write(`],${JSON.stringify(metadata).slice(1)}\\n`);\n        encoder.finish((encoderResult) => {\n            replayStats.addWroteData(metadata.view.id, encoderResult.rawBytesCount);\n            callback(metadata, encoderResult);\n        });\n    }\n    return { addRecord, flush };\n}\n//# sourceMappingURL=segment.js.map","import { isPageExitReason, ONE_SECOND, clearTimeout, setTimeout } from '@datadog/browser-core';\nimport { buildReplayPayload } from './buildReplayPayload';\nimport { createSegment } from './segment';\nexport const SEGMENT_DURATION_LIMIT = 5 * ONE_SECOND;\n/**\n * beacon payload max queue size implementation is 64kb\n * ensure that we leave room for logs, rum and potential other users\n */\nexport let SEGMENT_BYTES_LIMIT = 60000;\n// Segments are the main data structure for session replays. They contain context information used\n// for indexing or UI needs, and a list of records (RRWeb 'events', renamed to avoid confusing\n// namings). They are stored without any processing from the intake, and fetched one after the\n// other while a session is being replayed. Their encoding (deflate) are carefully crafted to allow\n// concatenating multiple segments together. Segments have a size overhead (metadata), so our goal is to\n// build segments containing as many records as possible while complying with the various flush\n// strategies to guarantee a good replay quality.\n//\n// When the recording starts, a segment is initially created.  The segment is flushed (finalized and\n// sent) based on various events (non-exhaustive list):\n//\n// * the page visibility change or becomes to unload\n// * the segment duration reaches a limit\n// * the encoded segment bytes count reaches a limit\n// * ...\n//\n// A segment cannot be created without its context.  If the RUM session ends and no session id is\n// available when creating a new segment, records will be ignored, until the session is renewed and\n// a new session id is available.\n//\n// Empty segments (segments with no record) aren't useful and should be ignored.\n//\n// To help investigate session replays issues, each segment is created with a \"creation reason\",\n// indicating why the session has been created.\nexport function startSegmentCollection(lifeCycle, configuration, sessionManager, viewHistory, httpRequest, encoder) {\n    return doStartSegmentCollection(lifeCycle, () => computeSegmentContext(configuration.applicationId, sessionManager, viewHistory), httpRequest, encoder);\n}\nexport function doStartSegmentCollection(lifeCycle, getSegmentContext, httpRequest, encoder) {\n    let state = {\n        status: 0 /* SegmentCollectionStatus.WaitingForInitialRecord */,\n        nextSegmentCreationReason: 'init',\n    };\n    const { unsubscribe: unsubscribeViewCreated } = lifeCycle.subscribe(2 /* LifeCycleEventType.VIEW_CREATED */, () => {\n        flushSegment('view_change');\n    });\n    const { unsubscribe: unsubscribePageMayExit } = lifeCycle.subscribe(11 /* LifeCycleEventType.PAGE_MAY_EXIT */, (pageMayExitEvent) => {\n        flushSegment(pageMayExitEvent.reason);\n    });\n    function flushSegment(flushReason) {\n        if (state.status === 1 /* SegmentCollectionStatus.SegmentPending */) {\n            state.segment.flush((metadata, encoderResult) => {\n                const payload = buildReplayPayload(encoderResult.output, metadata, encoderResult.rawBytesCount);\n                if (isPageExitReason(flushReason)) {\n                    httpRequest.sendOnExit(payload);\n                }\n                else {\n                    httpRequest.send(payload);\n                }\n            });\n            clearTimeout(state.expirationTimeoutId);\n        }\n        if (flushReason !== 'stop') {\n            state = {\n                status: 0 /* SegmentCollectionStatus.WaitingForInitialRecord */,\n                nextSegmentCreationReason: flushReason,\n            };\n        }\n        else {\n            state = {\n                status: 2 /* SegmentCollectionStatus.Stopped */,\n            };\n        }\n    }\n    return {\n        addRecord: (record) => {\n            if (state.status === 2 /* SegmentCollectionStatus.Stopped */) {\n                return;\n            }\n            if (state.status === 0 /* SegmentCollectionStatus.WaitingForInitialRecord */) {\n                const context = getSegmentContext();\n                if (!context) {\n                    return;\n                }\n                state = {\n                    status: 1 /* SegmentCollectionStatus.SegmentPending */,\n                    segment: createSegment({ encoder, context, creationReason: state.nextSegmentCreationReason }),\n                    expirationTimeoutId: setTimeout(() => {\n                        flushSegment('segment_duration_limit');\n                    }, SEGMENT_DURATION_LIMIT),\n                };\n            }\n            state.segment.addRecord(record, (encodedBytesCount) => {\n                if (encodedBytesCount > SEGMENT_BYTES_LIMIT) {\n                    flushSegment('segment_bytes_limit');\n                }\n            });\n        },\n        stop: () => {\n            flushSegment('stop');\n            unsubscribeViewCreated();\n            unsubscribePageMayExit();\n        },\n    };\n}\nexport function computeSegmentContext(applicationId, sessionManager, viewHistory) {\n    const session = sessionManager.findTrackedSession();\n    const viewContext = viewHistory.findView();\n    if (!session || !viewContext) {\n        return undefined;\n    }\n    return {\n        application: {\n            id: applicationId,\n        },\n        session: {\n            id: session.id,\n        },\n        view: {\n            id: viewContext.id,\n        },\n    };\n}\nexport function setSegmentBytesLimit(newSegmentBytesLimit = 60000) {\n    SEGMENT_BYTES_LIMIT = newSegmentBytesLimit;\n}\n//# sourceMappingURL=segmentCollection.js.map","import { getEventBridge } from '@datadog/browser-core';\nexport function startRecordBridge(viewHistory) {\n    const bridge = getEventBridge();\n    return {\n        addRecord: (record) => {\n            // Get the current active view, not at the time of the record, aligning with the segment logic.\n            // This approach could potentially associate the record to an incorrect view, in case the record date is in the past (e.g. frustration records).\n            // However the risk is minimal. We could address the issue when potential negative impact are identified.\n            const view = viewHistory.findView();\n            bridge.send('record', record, view.id);\n        },\n    };\n}\n//# sourceMappingURL=startRecordBridge.js.map","import { createHttpRequest, addTelemetryDebug, canUseEventBridge } from '@datadog/browser-core';\nimport { record } from '../domain/record';\nimport { startSegmentCollection, SEGMENT_BYTES_LIMIT } from '../domain/segmentCollection';\nimport { startRecordBridge } from '../domain/startRecordBridge';\nexport function startRecording(lifeCycle, configuration, sessionManager, viewHistory, encoder, httpRequest) {\n    const cleanupTasks = [];\n    const reportError = (error) => {\n        lifeCycle.notify(14 /* LifeCycleEventType.RAW_ERROR_COLLECTED */, { error });\n        addTelemetryDebug('Error reported to customer', { 'error.message': error.message });\n    };\n    const replayRequest = httpRequest || createHttpRequest(configuration.sessionReplayEndpointBuilder, SEGMENT_BYTES_LIMIT, reportError);\n    let addRecord;\n    if (!canUseEventBridge()) {\n        const segmentCollection = startSegmentCollection(lifeCycle, configuration, sessionManager, viewHistory, replayRequest, encoder);\n        addRecord = segmentCollection.addRecord;\n        cleanupTasks.push(segmentCollection.stop);\n    }\n    else {\n        ;\n        ({ addRecord } = startRecordBridge(viewHistory));\n    }\n    const { stop: stopRecording } = record({\n        emit: addRecord,\n        configuration,\n        lifeCycle,\n        viewHistory,\n    });\n    cleanupTasks.push(stopRecording);\n    return {\n        stop: () => {\n            cleanupTasks.forEach((task) => task());\n        },\n    };\n}\n//# sourceMappingURL=startRecording.js.map"],"names":["serializedNodeIds","hasSerializedNode","node","nodeAndAncestorsHaveSerializedNode","current","isNodeShadowRoot","getParentNode","getSerializedNodeId","setSerializedNodeId","serializeNodeId","getElementInputValue","element","nodePrivacyLevel","tagName","value","shouldMaskNode","type","CENSORED_STRING_MARK","URL_IN_CSS_REF","ABSOLUTE_URL","DATA_URI","switchToAbsoluteUrl","cssText","cssHref","matchingSubstring","singleQuote","urlWrappedInSingleQuotes","doubleQuote","urlWrappedInDoubleQuotes","urlNotWrappedInQuotes","url","quote","makeUrlAbsolute","baseUrl","buildUrl","TAG_NAME_REGEX","getValidTagName","processedTagName","censoredImageForSize","width","height","RecordType","NodeType","IncrementalSource","MouseInteractionType","MediaInteractionType","serializeStyleSheets","cssStyleSheets","cssStyleSheet","rules","cssRule","MAX_ATTRIBUTE_VALUE_CHAR_LENGTH","serializeAttribute","attributeName","configuration","NodePrivacyLevel","attributeValue","PRIVACY_ATTR_NAME","STABLE_ATTRIBUTES","image","CENSORED_IMG_MARK","sanitizeIfLongDataUrl","serializeAttributes","options","safeAttrs","doc","i","formValue","optionElement","stylesheet","s","getCssRulesString","inputElement","mediaElement","scrollTop","scrollLeft","serializationContext","styleSheetCssText","isSafari","getCssRuleStringForSafari","getCssRuleString","rule","isCSSStyleRule","escapeColon","isCSSImportRule","serializeNodeWithId","serializedNode","serializeNode","id","generateNextId","serializedNodeWithId","_nextId","serializeChildNodes","result","forEachChildNodes","childNode","serializedChildNode","serializeDocumentNode","serializeDocumentFragmentNode","serializeDocumentTypeNode","serializeElementNode","serializeTextNode","serializeCDataNode","document","isShadowRoot","documentType","isSVG","isSVGElement","reducePrivacyLevel","getNodeSelfPrivacyLevel","PRIVACY_ATTR_VALUE_HIDDEN","attributes","childNodes","hasChildNodes","childNodesSerializationOptions","el","textNode","textContent","getTextContent","serializeDocument","isTouchEvent","event","getEventTarget","isNodeShadowHost","TOLERANCE","isVisualViewportFactoredIn","visualViewport","convertMouseEventToLayoutCoordinates","clientX","clientY","normalized","getVisualViewport","assembleIncrementalSnapshot","source","data","timeStampNow","MOUSE_MOVE_OBSERVER_THRESHOLD","trackMove","moveCb","updatePosition","cancelThrottle","throttle","target","coordinates","tryToComputeCoordinates","position","removeListener","addEventListeners","x","y","visualViewportX","visualViewportY","addTelemetryDebug","eventTypeToMouseInteraction","trackMouseInteraction","mouseInteractionCb","recordIds","handler","getNodePrivacyLevel","interaction","record","SCROLL_OBSERVER_THRESHOLD","trackScroll","scrollCb","elementsScrollPositions","scrollPositions","getScrollY","getScrollX","addEventListener","VISUAL_VIEWPORT_OBSERVER_THRESHOLD","trackViewportResize","viewportResizeCb","viewportResizeSubscription","initViewportObservable","trackVisualViewportResize","visualViewportResizeCb","noop","updateDimension","trackMediaInteraction","mediaInteractionCb","trackStyleSheet","styleSheetCb","checkStyleSheetAndCallback","styleSheet","callback","instrumentationStoppers","instrumentMethod","index","instrumentGroupingCSSRuleClass","cls","path","getPathToNestedCSSRule","stopper","currentRule","trackFocus","focusCb","trackFrustration","lifeCycle","frustrationCb","frustrationSubscription","_a","_b","e","trackViewEnd","viewEndCb","viewEndSubscription","trackInput","inputCb","defaultPrivacyLevel","lastInputStateMap","stopEventListeners","onElementChange","stopPropertySetterInstrumentation","instrumentSetter","inputState","cbWithDedup","name","lastInputState","MUTATION_PROCESS_MAX_DELAY","MUTATION_PROCESS_MIN_DELAY","createMutationBatch","processMutationBatch","cancelScheduledFlush","pendingMutations","flush","throttledFlush","mutations","requestIdleCallback","trackMutation","mutationCallback","shadowRootsController","MutationObserver","getMutationObserverConstructor","mutationBatch","processMutations","observer","monitor","nodePrivacyLevelCache","mutation","removedNode","traverseRemovedShadowDom","filteredMutations","adds","removes","hasBeenSerialized","processChildListMutations","texts","processCharacterDataMutations","processAttributesMutations","addedAndMovedNodes","removedNodes","sortedAddedAndMovedNodes","sortAddedAndMovedNodes","addedNodeMutations","parentNodePrivacyLevel","parentNode","getNextSibling","removedNodeMutations","parent","nextSibling","textMutations","handledNodes","attributeMutations","handledElements","handledAttributes","emittedMutations","privacyLevel","transformedValue","inputValue","emittedMutation","nodes","a","b","shadowDomRemovedCallback","createElementsScrollPositions","scrollPositionsByElement","initShadowRootsController","controllerByShadowRoot","shadowRoot","mutationTracker","inputTracker","scrollTracker","entry","stop","startFullSnapshots","flushMutations","fullSnapshotCallback","takeFullSnapshot","timestamp","getViewportDimension","records","unsubscribe","view","initRecordIds","nextId","emit","emitAndComputeStats","sendToExtension","replayStats.addRecord","stopFullSnapshots","trackers","viewEndRecord","tracker","buildReplayPayload","metadata","rawSegmentBytesCount","formData","metadataAndSegmentSizes","serializedMetadataAndSegmentSizes","createSegment","context","creationReason","encoder","encodedBytesCount","viewId","replayStats.getSegmentsCount","replayStats.addSegment","addRecord","prefix","additionalEncodedBytesCount","encoderResult","replayStats.addWroteData","SEGMENT_DURATION_LIMIT","ONE_SECOND","SEGMENT_BYTES_LIMIT","startSegmentCollection","sessionManager","viewHistory","httpRequest","doStartSegmentCollection","computeSegmentContext","getSegmentContext","state","unsubscribeViewCreated","flushSegment","unsubscribePageMayExit","pageMayExitEvent","flushReason","payload","isPageExitReason","clearTimeout","setTimeout","applicationId","session","viewContext","startRecordBridge","bridge","getEventBridge","startRecording","cleanupTasks","reportError","error","replayRequest","createHttpRequest","canUseEventBridge","segmentCollection","stopRecording","task"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31]}