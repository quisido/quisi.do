{"version":3,"file":"startRecording-CiCa3x88.js","sources":["../../../../node_modules/@datadog/browser-rum/esm/types/sessionReplayConstants.js","../../../../node_modules/@datadog/browser-rum/esm/domain/record/eventsUtils.js","../../../../node_modules/@datadog/browser-rum/esm/domain/record/viewports.js","../../../../node_modules/@datadog/browser-rum/esm/domain/record/assembly.js","../../../../node_modules/@datadog/browser-rum/esm/domain/record/trackers/trackMove.js","../../../../node_modules/@datadog/browser-rum/esm/domain/record/trackers/trackMouseInteraction.js","../../../../node_modules/@datadog/browser-rum/esm/domain/record/trackers/trackScroll.js","../../../../node_modules/@datadog/browser-rum/esm/domain/record/trackers/trackViewportResize.js","../../../../node_modules/@datadog/browser-rum/esm/domain/record/trackers/trackMediaInteraction.js","../../../../node_modules/@datadog/browser-rum/esm/domain/record/trackers/trackStyleSheet.js","../../../../node_modules/@datadog/browser-rum/esm/domain/record/trackers/trackFocus.js","../../../../node_modules/@datadog/browser-rum/esm/domain/record/trackers/trackFrustration.js","../../../../node_modules/@datadog/browser-rum/esm/domain/record/trackers/trackViewEnd.js","../../../../node_modules/@datadog/browser-rum/esm/domain/record/serialization/serializationUtils.js","../../../../node_modules/@datadog/browser-rum/esm/domain/record/serialization/serializeStyleSheets.js","../../../../node_modules/@datadog/browser-rum/esm/domain/record/serialization/serializeAttribute.js","../../../../node_modules/@datadog/browser-rum/esm/domain/record/serialization/serializationStats.js","../../../../node_modules/@datadog/browser-rum/esm/domain/record/serialization/serializeAttributes.js","../../../../node_modules/@datadog/browser-rum/esm/domain/record/serialization/serializeNode.js","../../../../node_modules/@datadog/browser-rum/esm/domain/record/serialization/serializeDocument.js","../../../../node_modules/@datadog/browser-rum/esm/domain/record/serialization/serializationScope.js","../../../../node_modules/@datadog/browser-rum/esm/domain/record/trackers/trackInput.js","../../../../node_modules/@datadog/browser-rum/esm/domain/record/mutationBatch.js","../../../../node_modules/@datadog/browser-rum/esm/domain/record/trackers/trackMutation.js","../../../../node_modules/@datadog/browser-rum/esm/domain/record/elementsScrollPositions.js","../../../../node_modules/@datadog/browser-rum/esm/domain/record/shadowRootsController.js","../../../../node_modules/@datadog/browser-rum/esm/domain/record/startFullSnapshots.js","../../../../node_modules/@datadog/browser-rum/esm/domain/record/recordIds.js","../../../../node_modules/@datadog/browser-rum/esm/domain/record/nodeIds.js","../../../../node_modules/@datadog/browser-rum/esm/domain/record/record.js","../../../../node_modules/@datadog/browser-rum/esm/domain/segmentCollection/buildReplayPayload.js","../../../../node_modules/@datadog/browser-rum/esm/domain/segmentCollection/segment.js","../../../../node_modules/@datadog/browser-rum/esm/domain/segmentCollection/segmentCollection.js","../../../../node_modules/@datadog/browser-rum/esm/domain/segmentCollection/startSegmentTelemetry.js","../../../../node_modules/@datadog/browser-rum/esm/domain/startRecordBridge.js","../../../../node_modules/@datadog/browser-rum/esm/boot/startRecording.js"],"sourcesContent":["export const RecordType = {\n    FullSnapshot: 2,\n    IncrementalSnapshot: 3,\n    Meta: 4,\n    Focus: 6,\n    ViewEnd: 7,\n    VisualViewport: 8,\n    FrustrationRecord: 9,\n};\nexport const NodeType = {\n    Document: 0,\n    DocumentType: 1,\n    Element: 2,\n    Text: 3,\n    CDATA: 4,\n    DocumentFragment: 11,\n};\nexport const IncrementalSource = {\n    Mutation: 0,\n    MouseMove: 1,\n    MouseInteraction: 2,\n    Scroll: 3,\n    ViewportResize: 4,\n    Input: 5,\n    TouchMove: 6,\n    MediaInteraction: 7,\n    StyleSheetRule: 8,\n    // CanvasMutation : 9,\n    // Font : 10,\n};\nexport const MouseInteractionType = {\n    MouseUp: 0,\n    MouseDown: 1,\n    Click: 2,\n    ContextMenu: 3,\n    DblClick: 4,\n    Focus: 5,\n    Blur: 6,\n    TouchStart: 7,\n    TouchEnd: 9,\n};\nexport const MediaInteractionType = {\n    Play: 0,\n    Pause: 1,\n};\n//# sourceMappingURL=sessionReplayConstants.js.map","import { isNodeShadowHost } from '@datadog/browser-rum-core';\nexport function isTouchEvent(event) {\n    return Boolean(event.changedTouches);\n}\nexport function getEventTarget(event) {\n    if (event.composed === true && isNodeShadowHost(event.target)) {\n        return event.composedPath()[0];\n    }\n    return event.target;\n}\n//# sourceMappingURL=eventsUtils.js.map","/**\n * Browsers have not standardized various dimension properties. Mobile devices typically report\n * dimensions in reference to the visual viewport, while desktop uses the layout viewport. For example,\n * Mobile Chrome will change innerWidth when a pinch zoom takes place, while Chrome Desktop (mac) will not.\n *\n * With the new Viewport API, we now calculate and normalize dimension properties to the layout viewport.\n * If the VisualViewport API is not supported by a browser, it isn't reasonably possible to detect or normalize\n * which viewport is being measured. Therefore these exported functions will fallback to assuming that the layout\n * viewport is being measured by the browser\n */\n// Scrollbar widths vary across properties on different devices and browsers\nconst TOLERANCE = 25;\n/**\n * Use the Visual Viewport API's properties to measure scrollX/Y in reference to the layout viewport\n * in order to determine if window.scrollX/Y is measuring the layout or visual viewport.\n * This finding corresponds to which viewport mouseEvent.clientX/Y and window.innerWidth/Height measures.\n */\nfunction isVisualViewportFactoredIn(visualViewport) {\n    return (Math.abs(visualViewport.pageTop - visualViewport.offsetTop - window.scrollY) > TOLERANCE ||\n        Math.abs(visualViewport.pageLeft - visualViewport.offsetLeft - window.scrollX) > TOLERANCE);\n}\nexport const convertMouseEventToLayoutCoordinates = (clientX, clientY) => {\n    const visualViewport = window.visualViewport;\n    const normalized = {\n        layoutViewportX: clientX,\n        layoutViewportY: clientY,\n        visualViewportX: clientX,\n        visualViewportY: clientY,\n    };\n    if (!visualViewport) {\n        // On old browsers, we cannot normalize, so fallback to clientX/Y\n        return normalized;\n    }\n    else if (isVisualViewportFactoredIn(visualViewport)) {\n        // Typically Mobile Devices\n        normalized.layoutViewportX = Math.round(clientX + visualViewport.offsetLeft);\n        normalized.layoutViewportY = Math.round(clientY + visualViewport.offsetTop);\n    }\n    else {\n        // Typically Desktop Devices\n        normalized.visualViewportX = Math.round(clientX - visualViewport.offsetLeft);\n        normalized.visualViewportY = Math.round(clientY - visualViewport.offsetTop);\n    }\n    return normalized;\n};\nexport const getVisualViewport = (visualViewport) => ({\n    scale: visualViewport.scale,\n    offsetLeft: visualViewport.offsetLeft,\n    offsetTop: visualViewport.offsetTop,\n    pageLeft: visualViewport.pageLeft,\n    pageTop: visualViewport.pageTop,\n    height: visualViewport.height,\n    width: visualViewport.width,\n});\n//# sourceMappingURL=viewports.js.map","import { timeStampNow } from '@datadog/browser-core';\nimport { RecordType } from '../../types';\nexport function assembleIncrementalSnapshot(source, data) {\n    return {\n        data: {\n            source,\n            ...data,\n        },\n        type: RecordType.IncrementalSnapshot,\n        timestamp: timeStampNow(),\n    };\n}\n//# sourceMappingURL=assembly.js.map","import { addEventListeners, throttle } from '@datadog/browser-core';\nimport { IncrementalSource } from '../../../types';\nimport { getEventTarget, isTouchEvent } from '../eventsUtils';\nimport { convertMouseEventToLayoutCoordinates } from '../viewports';\nimport { assembleIncrementalSnapshot } from '../assembly';\nconst MOUSE_MOVE_OBSERVER_THRESHOLD = 50;\nexport function trackMove(configuration, scope, moveCb) {\n    const { throttled: updatePosition, cancel: cancelThrottle } = throttle((event) => {\n        const target = getEventTarget(event);\n        const id = scope.nodeIds.get(target);\n        if (id === undefined) {\n            return;\n        }\n        const coordinates = tryToComputeCoordinates(event);\n        if (!coordinates) {\n            return;\n        }\n        const position = {\n            id,\n            timeOffset: 0,\n            x: coordinates.x,\n            y: coordinates.y,\n        };\n        moveCb(assembleIncrementalSnapshot(isTouchEvent(event) ? IncrementalSource.TouchMove : IncrementalSource.MouseMove, { positions: [position] }));\n    }, MOUSE_MOVE_OBSERVER_THRESHOLD, {\n        trailing: false,\n    });\n    const { stop: removeListener } = addEventListeners(configuration, document, [\"mousemove\" /* DOM_EVENT.MOUSE_MOVE */, \"touchmove\" /* DOM_EVENT.TOUCH_MOVE */], updatePosition, {\n        capture: true,\n        passive: true,\n    });\n    return {\n        stop: () => {\n            removeListener();\n            cancelThrottle();\n        },\n    };\n}\nexport function tryToComputeCoordinates(event) {\n    let { clientX: x, clientY: y } = isTouchEvent(event) ? event.changedTouches[0] : event;\n    if (window.visualViewport) {\n        const { visualViewportX, visualViewportY } = convertMouseEventToLayoutCoordinates(x, y);\n        x = visualViewportX;\n        y = visualViewportY;\n    }\n    if (!Number.isFinite(x) || !Number.isFinite(y)) {\n        return undefined;\n    }\n    return { x, y };\n}\n//# sourceMappingURL=trackMove.js.map","import { addEventListeners } from '@datadog/browser-core';\nimport { getNodePrivacyLevel, NodePrivacyLevel } from '@datadog/browser-rum-core';\nimport { IncrementalSource, MouseInteractionType } from '../../../types';\nimport { assembleIncrementalSnapshot } from '../assembly';\nimport { getEventTarget } from '../eventsUtils';\nimport { tryToComputeCoordinates } from './trackMove';\nconst eventTypeToMouseInteraction = {\n    // Listen for pointerup DOM events instead of mouseup for MouseInteraction/MouseUp records. This\n    // allows to reference such records from Frustration records.\n    //\n    // In the context of supporting Mobile Session Replay, we introduced `PointerInteraction` records\n    // used by the Mobile SDKs in place of `MouseInteraction`. In the future, we should replace\n    // `MouseInteraction` by `PointerInteraction` in the Browser SDK so we have an uniform way to\n    // convey such interaction. This would cleanly solve the issue since we would have\n    // `PointerInteraction/Up` records that we could reference from `Frustration` records.\n    [\"pointerup\" /* DOM_EVENT.POINTER_UP */]: MouseInteractionType.MouseUp,\n    [\"mousedown\" /* DOM_EVENT.MOUSE_DOWN */]: MouseInteractionType.MouseDown,\n    [\"click\" /* DOM_EVENT.CLICK */]: MouseInteractionType.Click,\n    [\"contextmenu\" /* DOM_EVENT.CONTEXT_MENU */]: MouseInteractionType.ContextMenu,\n    [\"dblclick\" /* DOM_EVENT.DBL_CLICK */]: MouseInteractionType.DblClick,\n    [\"focus\" /* DOM_EVENT.FOCUS */]: MouseInteractionType.Focus,\n    [\"blur\" /* DOM_EVENT.BLUR */]: MouseInteractionType.Blur,\n    [\"touchstart\" /* DOM_EVENT.TOUCH_START */]: MouseInteractionType.TouchStart,\n    [\"touchend\" /* DOM_EVENT.TOUCH_END */]: MouseInteractionType.TouchEnd,\n};\nexport function trackMouseInteraction(configuration, scope, mouseInteractionCb, recordIds) {\n    const handler = (event) => {\n        const target = getEventTarget(event);\n        const id = scope.nodeIds.get(target);\n        if (id === undefined ||\n            getNodePrivacyLevel(target, configuration.defaultPrivacyLevel) === NodePrivacyLevel.HIDDEN) {\n            return;\n        }\n        const type = eventTypeToMouseInteraction[event.type];\n        let interaction;\n        if (type !== MouseInteractionType.Blur && type !== MouseInteractionType.Focus) {\n            const coordinates = tryToComputeCoordinates(event);\n            if (!coordinates) {\n                return;\n            }\n            interaction = { id, type, x: coordinates.x, y: coordinates.y };\n        }\n        else {\n            interaction = { id, type };\n        }\n        const record = {\n            id: recordIds.getIdForEvent(event),\n            ...assembleIncrementalSnapshot(IncrementalSource.MouseInteraction, interaction),\n        };\n        mouseInteractionCb(record);\n    };\n    return addEventListeners(configuration, document, Object.keys(eventTypeToMouseInteraction), handler, {\n        capture: true,\n        passive: true,\n    });\n}\n//# sourceMappingURL=trackMouseInteraction.js.map","import { throttle, addEventListener } from '@datadog/browser-core';\nimport { getScrollX, getScrollY, getNodePrivacyLevel, NodePrivacyLevel } from '@datadog/browser-rum-core';\nimport { getEventTarget } from '../eventsUtils';\nimport { IncrementalSource } from '../../../types';\nimport { assembleIncrementalSnapshot } from '../assembly';\nconst SCROLL_OBSERVER_THRESHOLD = 100;\nexport function trackScroll(configuration, scope, scrollCb, elementsScrollPositions, target = document) {\n    const { throttled: updatePosition, cancel: cancelThrottle } = throttle((event) => {\n        const target = getEventTarget(event);\n        if (!target) {\n            return;\n        }\n        const id = scope.nodeIds.get(target);\n        if (id === undefined ||\n            getNodePrivacyLevel(target, configuration.defaultPrivacyLevel) === NodePrivacyLevel.HIDDEN) {\n            return;\n        }\n        const scrollPositions = target === document\n            ? {\n                scrollTop: getScrollY(),\n                scrollLeft: getScrollX(),\n            }\n            : {\n                scrollTop: Math.round(target.scrollTop),\n                scrollLeft: Math.round(target.scrollLeft),\n            };\n        elementsScrollPositions.set(target, scrollPositions);\n        scrollCb(assembleIncrementalSnapshot(IncrementalSource.Scroll, {\n            id,\n            x: scrollPositions.scrollLeft,\n            y: scrollPositions.scrollTop,\n        }));\n    }, SCROLL_OBSERVER_THRESHOLD);\n    const { stop: removeListener } = addEventListener(configuration, target, \"scroll\" /* DOM_EVENT.SCROLL */, updatePosition, {\n        capture: true,\n        passive: true,\n    });\n    return {\n        stop: () => {\n            removeListener();\n            cancelThrottle();\n        },\n    };\n}\n//# sourceMappingURL=trackScroll.js.map","import { throttle, addEventListeners, timeStampNow, noop } from '@datadog/browser-core';\nimport { initViewportObservable } from '@datadog/browser-rum-core';\nimport { IncrementalSource, RecordType } from '../../../types';\nimport { getVisualViewport } from '../viewports';\nimport { assembleIncrementalSnapshot } from '../assembly';\nconst VISUAL_VIEWPORT_OBSERVER_THRESHOLD = 200;\nexport function trackViewportResize(configuration, viewportResizeCb) {\n    const viewportResizeSubscription = initViewportObservable(configuration).subscribe((data) => {\n        viewportResizeCb(assembleIncrementalSnapshot(IncrementalSource.ViewportResize, data));\n    });\n    return {\n        stop: () => {\n            viewportResizeSubscription.unsubscribe();\n        },\n    };\n}\nexport function trackVisualViewportResize(configuration, visualViewportResizeCb) {\n    const visualViewport = window.visualViewport;\n    if (!visualViewport) {\n        return { stop: noop };\n    }\n    const { throttled: updateDimension, cancel: cancelThrottle } = throttle(() => {\n        visualViewportResizeCb({\n            data: getVisualViewport(visualViewport),\n            type: RecordType.VisualViewport,\n            timestamp: timeStampNow(),\n        });\n    }, VISUAL_VIEWPORT_OBSERVER_THRESHOLD, {\n        trailing: false,\n    });\n    const { stop: removeListener } = addEventListeners(configuration, visualViewport, [\"resize\" /* DOM_EVENT.RESIZE */, \"scroll\" /* DOM_EVENT.SCROLL */], updateDimension, {\n        capture: true,\n        passive: true,\n    });\n    return {\n        stop: () => {\n            removeListener();\n            cancelThrottle();\n        },\n    };\n}\n//# sourceMappingURL=trackViewportResize.js.map","import { addEventListeners } from '@datadog/browser-core';\nimport { NodePrivacyLevel, getNodePrivacyLevel } from '@datadog/browser-rum-core';\nimport { IncrementalSource, MediaInteractionType } from '../../../types';\nimport { getEventTarget } from '../eventsUtils';\nimport { assembleIncrementalSnapshot } from '../assembly';\nexport function trackMediaInteraction(configuration, scope, mediaInteractionCb) {\n    return addEventListeners(configuration, document, [\"play\" /* DOM_EVENT.PLAY */, \"pause\" /* DOM_EVENT.PAUSE */], (event) => {\n        const target = getEventTarget(event);\n        if (!target) {\n            return;\n        }\n        const id = scope.nodeIds.get(target);\n        if (id === undefined ||\n            getNodePrivacyLevel(target, configuration.defaultPrivacyLevel) === NodePrivacyLevel.HIDDEN) {\n            return;\n        }\n        mediaInteractionCb(assembleIncrementalSnapshot(IncrementalSource.MediaInteraction, {\n            id,\n            type: event.type === \"play\" /* DOM_EVENT.PLAY */ ? MediaInteractionType.Play : MediaInteractionType.Pause,\n        }));\n    }, {\n        capture: true,\n        passive: true,\n    });\n}\n//# sourceMappingURL=trackMediaInteraction.js.map","import { instrumentMethod } from '@datadog/browser-core';\nimport { IncrementalSource } from '../../../types';\nimport { assembleIncrementalSnapshot } from '../assembly';\nexport function trackStyleSheet(scope, styleSheetCb) {\n    function checkStyleSheetAndCallback(styleSheet, callback) {\n        if (!styleSheet || !styleSheet.ownerNode) {\n            return;\n        }\n        const id = scope.nodeIds.get(styleSheet.ownerNode);\n        if (id === undefined) {\n            return;\n        }\n        callback(id);\n    }\n    const instrumentationStoppers = [\n        instrumentMethod(CSSStyleSheet.prototype, 'insertRule', ({ target: styleSheet, parameters: [rule, index] }) => {\n            checkStyleSheetAndCallback(styleSheet, (id) => styleSheetCb(assembleIncrementalSnapshot(IncrementalSource.StyleSheetRule, {\n                id,\n                adds: [{ rule, index }],\n            })));\n        }),\n        instrumentMethod(CSSStyleSheet.prototype, 'deleteRule', ({ target: styleSheet, parameters: [index] }) => {\n            checkStyleSheetAndCallback(styleSheet, (id) => styleSheetCb(assembleIncrementalSnapshot(IncrementalSource.StyleSheetRule, {\n                id,\n                removes: [{ index }],\n            })));\n        }),\n    ];\n    if (typeof CSSGroupingRule !== 'undefined') {\n        instrumentGroupingCSSRuleClass(CSSGroupingRule);\n    }\n    else {\n        instrumentGroupingCSSRuleClass(CSSMediaRule);\n        instrumentGroupingCSSRuleClass(CSSSupportsRule);\n    }\n    function instrumentGroupingCSSRuleClass(cls) {\n        instrumentationStoppers.push(instrumentMethod(cls.prototype, 'insertRule', ({ target: styleSheet, parameters: [rule, index] }) => {\n            checkStyleSheetAndCallback(styleSheet.parentStyleSheet, (id) => {\n                const path = getPathToNestedCSSRule(styleSheet);\n                if (path) {\n                    path.push(index || 0);\n                    styleSheetCb(assembleIncrementalSnapshot(IncrementalSource.StyleSheetRule, {\n                        id,\n                        adds: [{ rule, index: path }],\n                    }));\n                }\n            });\n        }), instrumentMethod(cls.prototype, 'deleteRule', ({ target: styleSheet, parameters: [index] }) => {\n            checkStyleSheetAndCallback(styleSheet.parentStyleSheet, (id) => {\n                const path = getPathToNestedCSSRule(styleSheet);\n                if (path) {\n                    path.push(index);\n                    styleSheetCb(assembleIncrementalSnapshot(IncrementalSource.StyleSheetRule, {\n                        id,\n                        removes: [{ index: path }],\n                    }));\n                }\n            });\n        }));\n    }\n    return {\n        stop: () => {\n            instrumentationStoppers.forEach((stopper) => stopper.stop());\n        },\n    };\n}\nexport function getPathToNestedCSSRule(rule) {\n    const path = [];\n    let currentRule = rule;\n    while (currentRule.parentRule) {\n        const rules = Array.from(currentRule.parentRule.cssRules);\n        const index = rules.indexOf(currentRule);\n        path.unshift(index);\n        currentRule = currentRule.parentRule;\n    }\n    // A rule may not be attached to a stylesheet\n    if (!currentRule.parentStyleSheet) {\n        return;\n    }\n    const rules = Array.from(currentRule.parentStyleSheet.cssRules);\n    const index = rules.indexOf(currentRule);\n    path.unshift(index);\n    return path;\n}\n//# sourceMappingURL=trackStyleSheet.js.map","import { addEventListeners, timeStampNow } from '@datadog/browser-core';\nimport { RecordType } from '../../../types';\nexport function trackFocus(configuration, focusCb) {\n    return addEventListeners(configuration, window, [\"focus\" /* DOM_EVENT.FOCUS */, \"blur\" /* DOM_EVENT.BLUR */], () => {\n        focusCb({\n            data: { has_focus: document.hasFocus() },\n            type: RecordType.Focus,\n            timestamp: timeStampNow(),\n        });\n    });\n}\n//# sourceMappingURL=trackFocus.js.map","import { ActionType, RumEventType } from '@datadog/browser-rum-core';\nimport { RecordType } from '../../../types';\nexport function trackFrustration(lifeCycle, frustrationCb, recordIds) {\n    const frustrationSubscription = lifeCycle.subscribe(12 /* LifeCycleEventType.RAW_RUM_EVENT_COLLECTED */, (data) => {\n        var _a, _b;\n        if (data.rawRumEvent.type === RumEventType.ACTION &&\n            data.rawRumEvent.action.type === ActionType.CLICK &&\n            ((_b = (_a = data.rawRumEvent.action.frustration) === null || _a === void 0 ? void 0 : _a.type) === null || _b === void 0 ? void 0 : _b.length) &&\n            'events' in data.domainContext &&\n            data.domainContext.events &&\n            data.domainContext.events.length) {\n            frustrationCb({\n                timestamp: data.rawRumEvent.date,\n                type: RecordType.FrustrationRecord,\n                data: {\n                    frustrationTypes: data.rawRumEvent.action.frustration.type,\n                    recordIds: data.domainContext.events.map((e) => recordIds.getIdForEvent(e)),\n                },\n            });\n        }\n    });\n    return {\n        stop: () => {\n            frustrationSubscription.unsubscribe();\n        },\n    };\n}\n//# sourceMappingURL=trackFrustration.js.map","import { timeStampNow } from '@datadog/browser-core';\nimport { RecordType } from '../../../types';\nexport function trackViewEnd(lifeCycle, viewEndCb) {\n    const viewEndSubscription = lifeCycle.subscribe(5 /* LifeCycleEventType.VIEW_ENDED */, () => {\n        viewEndCb({\n            timestamp: timeStampNow(),\n            type: RecordType.ViewEnd,\n        });\n    });\n    return {\n        stop: () => {\n            viewEndSubscription.unsubscribe();\n        },\n    };\n}\n//# sourceMappingURL=trackViewEnd.js.map","import { buildUrl } from '@datadog/browser-core';\nimport { CENSORED_STRING_MARK, shouldMaskNode } from '@datadog/browser-rum-core';\n/**\n * Get the element \"value\" to be serialized as an attribute or an input update record. It respects\n * the input privacy mode of the element.\n * PERFROMANCE OPTIMIZATION: Assumes that privacy level `HIDDEN` is never encountered because of earlier checks.\n */\nexport function getElementInputValue(element, nodePrivacyLevel) {\n    /*\n     BROWSER SPEC NOTE: <input>, <select>\n     For some <input> elements, the `value` is an exceptional property/attribute that has the\n     value synced between el.value and el.getAttribute()\n     input[type=button,checkbox,hidden,image,radio,reset,submit]\n     */\n    const tagName = element.tagName;\n    const value = element.value;\n    if (shouldMaskNode(element, nodePrivacyLevel)) {\n        const type = element.type;\n        if (tagName === 'INPUT' && (type === 'button' || type === 'submit' || type === 'reset')) {\n            // Overrule `MASK` privacy level for button-like element values, as they are used during replay\n            // to display their label. They can still be hidden via the \"hidden\" privacy attribute or class name.\n            return value;\n        }\n        else if (!value || tagName === 'OPTION') {\n            // <Option> value provides no benefit\n            return;\n        }\n        return CENSORED_STRING_MARK;\n    }\n    if (tagName === 'OPTION' || tagName === 'SELECT') {\n        return element.value;\n    }\n    if (tagName !== 'INPUT' && tagName !== 'TEXTAREA') {\n        return;\n    }\n    return value;\n}\nexport const URL_IN_CSS_REF = /url\\((?:(')([^']*)'|(\")([^\"]*)\"|([^)]*))\\)/gm;\nexport const ABSOLUTE_URL = /^[A-Za-z]+:|^\\/\\//;\nexport const DATA_URI = /^[\"']?data:.*,/i;\nexport function switchToAbsoluteUrl(cssText, cssHref) {\n    return cssText.replace(URL_IN_CSS_REF, (matchingSubstring, singleQuote, urlWrappedInSingleQuotes, doubleQuote, urlWrappedInDoubleQuotes, urlNotWrappedInQuotes) => {\n        const url = urlWrappedInSingleQuotes || urlWrappedInDoubleQuotes || urlNotWrappedInQuotes;\n        if (!cssHref || !url || ABSOLUTE_URL.test(url) || DATA_URI.test(url)) {\n            return matchingSubstring;\n        }\n        const quote = singleQuote || doubleQuote || '';\n        return `url(${quote}${makeUrlAbsolute(url, cssHref)}${quote})`;\n    });\n}\nfunction makeUrlAbsolute(url, baseUrl) {\n    try {\n        return buildUrl(url, baseUrl).href;\n    }\n    catch (_a) {\n        return url;\n    }\n}\nconst TAG_NAME_REGEX = /[^a-z1-6-_]/;\nexport function getValidTagName(tagName) {\n    const processedTagName = tagName.toLowerCase().trim();\n    if (TAG_NAME_REGEX.test(processedTagName)) {\n        // if the tag name is odd and we cannot extract\n        // anything from the string, then we return a\n        // generic div\n        return 'div';\n    }\n    return processedTagName;\n}\nexport function censoredImageForSize(width, height) {\n    return `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='${width}' height='${height}' style='background-color:silver'%3E%3C/svg%3E`;\n}\n//# sourceMappingURL=serializationUtils.js.map","export function serializeStyleSheets(cssStyleSheets) {\n    if (cssStyleSheets === undefined || cssStyleSheets.length === 0) {\n        return undefined;\n    }\n    return cssStyleSheets.map((cssStyleSheet) => {\n        const rules = cssStyleSheet.cssRules || cssStyleSheet.rules;\n        const cssRules = Array.from(rules, (cssRule) => cssRule.cssText);\n        const styleSheet = {\n            cssRules,\n            disabled: cssStyleSheet.disabled || undefined,\n            media: cssStyleSheet.media.length > 0 ? Array.from(cssStyleSheet.media) : undefined,\n        };\n        return styleSheet;\n    });\n}\n//# sourceMappingURL=serializeStyleSheets.js.map","import { NodePrivacyLevel, CENSORED_STRING_MARK, CENSORED_IMG_MARK, sanitizeIfLongDataUrl, shouldMaskAttribute, } from '@datadog/browser-rum-core';\nimport { censoredImageForSize } from './serializationUtils';\n// TODO: temporarily bump the Session Replay limit to 1Mb for dataUrls\n// This limit should be removed after [PANA-2843] is implemented\nexport const MAX_ATTRIBUTE_VALUE_CHAR_LENGTH = 1000000;\nexport function serializeAttribute(element, nodePrivacyLevel, attributeName, configuration) {\n    if (nodePrivacyLevel === NodePrivacyLevel.HIDDEN) {\n        // dup condition for direct access case\n        return null;\n    }\n    const attributeValue = element.getAttribute(attributeName);\n    const tagName = element.tagName;\n    if (shouldMaskAttribute(tagName, attributeName, attributeValue, nodePrivacyLevel, configuration)) {\n        // mask image URLs\n        if (tagName === 'IMG') {\n            // generate image with similar dimension than the original to have the same rendering behaviour\n            const image = element;\n            if (image.naturalWidth > 0) {\n                return censoredImageForSize(image.naturalWidth, image.naturalHeight);\n            }\n            const { width, height } = element.getBoundingClientRect();\n            if (width > 0 || height > 0) {\n                return censoredImageForSize(width, height);\n            }\n            // if we can't get the image size, fallback to the censored image\n            return CENSORED_IMG_MARK;\n        }\n        if (tagName === 'SOURCE') {\n            return CENSORED_IMG_MARK;\n        }\n        return CENSORED_STRING_MARK;\n    }\n    if (!attributeValue || typeof attributeValue !== 'string') {\n        return attributeValue;\n    }\n    return sanitizeIfLongDataUrl(attributeValue, MAX_ATTRIBUTE_VALUE_CHAR_LENGTH);\n}\n//# sourceMappingURL=serializeAttribute.js.map","export function createSerializationStats() {\n    return {\n        cssText: {\n            count: 0,\n            max: 0,\n            sum: 0,\n        },\n        serializationDuration: {\n            count: 0,\n            max: 0,\n            sum: 0,\n        },\n    };\n}\nexport function updateSerializationStats(stats, metric, value) {\n    stats[metric].count += 1;\n    stats[metric].max = Math.max(stats[metric].max, value);\n    stats[metric].sum += value;\n}\nexport function aggregateSerializationStats(aggregateStats, stats) {\n    for (const metric of ['cssText', 'serializationDuration']) {\n        aggregateStats[metric].count += stats[metric].count;\n        aggregateStats[metric].max = Math.max(aggregateStats[metric].max, stats[metric].max);\n        aggregateStats[metric].sum += stats[metric].sum;\n    }\n}\n//# sourceMappingURL=serializationStats.js.map","import { NodePrivacyLevel, shouldMaskNode } from '@datadog/browser-rum-core';\nimport { isSafari } from '@datadog/browser-core';\nimport { getElementInputValue, switchToAbsoluteUrl, getValidTagName } from './serializationUtils';\nimport { serializeAttribute } from './serializeAttribute';\nimport { updateSerializationStats } from './serializationStats';\nexport function serializeAttributes(element, nodePrivacyLevel, options) {\n    if (nodePrivacyLevel === NodePrivacyLevel.HIDDEN) {\n        return {};\n    }\n    const safeAttrs = {};\n    const tagName = getValidTagName(element.tagName);\n    const doc = element.ownerDocument;\n    for (let i = 0; i < element.attributes.length; i += 1) {\n        const attribute = element.attributes.item(i);\n        const attributeName = attribute.name;\n        const attributeValue = serializeAttribute(element, nodePrivacyLevel, attributeName, options.configuration);\n        if (attributeValue !== null) {\n            safeAttrs[attributeName] = attributeValue;\n        }\n    }\n    if (element.value &&\n        (tagName === 'textarea' || tagName === 'select' || tagName === 'option' || tagName === 'input')) {\n        const formValue = getElementInputValue(element, nodePrivacyLevel);\n        if (formValue !== undefined) {\n            safeAttrs.value = formValue;\n        }\n    }\n    /**\n     * <Option> can be selected, which occurs if its `value` matches ancestor `<Select>.value`\n     */\n    if (tagName === 'option' && nodePrivacyLevel === NodePrivacyLevel.ALLOW) {\n        // For privacy=`MASK`, all the values would be the same, so skip.\n        const optionElement = element;\n        if (optionElement.selected) {\n            safeAttrs.selected = optionElement.selected;\n        }\n    }\n    // remote css\n    if (tagName === 'link') {\n        const stylesheet = Array.from(doc.styleSheets).find((s) => s.href === element.href);\n        const cssText = getCssRulesString(stylesheet);\n        if (cssText && stylesheet) {\n            updateSerializationStats(options.serializationContext.serializationStats, 'cssText', cssText.length);\n            safeAttrs._cssText = cssText;\n        }\n    }\n    // dynamic stylesheet\n    if (tagName === 'style' && element.sheet) {\n        const cssText = getCssRulesString(element.sheet);\n        if (cssText) {\n            updateSerializationStats(options.serializationContext.serializationStats, 'cssText', cssText.length);\n            safeAttrs._cssText = cssText;\n        }\n    }\n    /**\n     * Forms: input[type=checkbox,radio]\n     * The `checked` property for <input> is a little bit special:\n     * 1. el.checked is a setter that returns if truthy.\n     * 2. getAttribute returns the string value\n     * getAttribute('checked') does not sync with `Element.checked`, so use JS property\n     * NOTE: `checked` property exists on `HTMLInputElement`. For serializer assumptions, we check for type=radio|check.\n     */\n    const inputElement = element;\n    if (tagName === 'input' && (inputElement.type === 'radio' || inputElement.type === 'checkbox')) {\n        if (nodePrivacyLevel === NodePrivacyLevel.ALLOW) {\n            safeAttrs.checked = !!inputElement.checked;\n        }\n        else if (shouldMaskNode(inputElement, nodePrivacyLevel)) {\n            delete safeAttrs.checked;\n        }\n    }\n    /**\n     * Serialize the media playback state\n     */\n    if (tagName === 'audio' || tagName === 'video') {\n        const mediaElement = element;\n        safeAttrs.rr_mediaState = mediaElement.paused ? 'paused' : 'played';\n    }\n    /**\n     * Serialize the scroll state for each element only for full snapshot\n     */\n    let scrollTop;\n    let scrollLeft;\n    const serializationContext = options.serializationContext;\n    switch (serializationContext.status) {\n        case 0 /* SerializationContextStatus.INITIAL_FULL_SNAPSHOT */:\n            scrollTop = Math.round(element.scrollTop);\n            scrollLeft = Math.round(element.scrollLeft);\n            if (scrollTop || scrollLeft) {\n                serializationContext.elementsScrollPositions.set(element, { scrollTop, scrollLeft });\n            }\n            break;\n        case 1 /* SerializationContextStatus.SUBSEQUENT_FULL_SNAPSHOT */:\n            if (serializationContext.elementsScrollPositions.has(element)) {\n                ;\n                ({ scrollTop, scrollLeft } = serializationContext.elementsScrollPositions.get(element));\n            }\n            break;\n    }\n    if (scrollLeft) {\n        safeAttrs.rr_scrollLeft = scrollLeft;\n    }\n    if (scrollTop) {\n        safeAttrs.rr_scrollTop = scrollTop;\n    }\n    return safeAttrs;\n}\nexport function getCssRulesString(cssStyleSheet) {\n    if (!cssStyleSheet) {\n        return null;\n    }\n    let rules;\n    try {\n        rules = cssStyleSheet.rules || cssStyleSheet.cssRules;\n    }\n    catch (_a) {\n        // if css is protected by CORS we cannot access cssRules see: https://www.w3.org/TR/cssom-1/#the-cssstylesheet-interface\n    }\n    if (!rules) {\n        return null;\n    }\n    const styleSheetCssText = Array.from(rules, isSafari() ? getCssRuleStringForSafari : getCssRuleString).join('');\n    return switchToAbsoluteUrl(styleSheetCssText, cssStyleSheet.href);\n}\nfunction getCssRuleStringForSafari(rule) {\n    // Safari does not escape attribute selectors containing : properly\n    // https://bugs.webkit.org/show_bug.cgi?id=184604\n    if (isCSSStyleRule(rule) && rule.selectorText.includes(':')) {\n        // This regex replaces [foo:bar] by [foo\\\\:bar]\n        const escapeColon = /(\\[[\\w-]+[^\\\\])(:[^\\]]+\\])/g;\n        return rule.cssText.replace(escapeColon, '$1\\\\$2');\n    }\n    return getCssRuleString(rule);\n}\nfunction getCssRuleString(rule) {\n    // If it's an @import rule, try to inline sub-rules recursively with `getCssRulesString`. This\n    // operation can fail if the imported stylesheet is protected by CORS, in which case we fallback\n    // to the @import rule CSS text.\n    return (isCSSImportRule(rule) && getCssRulesString(rule.styleSheet)) || rule.cssText;\n}\nfunction isCSSImportRule(rule) {\n    return 'styleSheet' in rule;\n}\nfunction isCSSStyleRule(rule) {\n    return 'selectorText' in rule;\n}\n//# sourceMappingURL=serializeAttributes.js.map","import { reducePrivacyLevel, getNodeSelfPrivacyLevel, getTextContent, isNodeShadowRoot, hasChildNodes, forEachChildNodes, NodePrivacyLevel, PRIVACY_ATTR_NAME, PRIVACY_ATTR_VALUE_HIDDEN, } from '@datadog/browser-rum-core';\nimport { NodeType } from '../../../types';\nimport { getValidTagName } from './serializationUtils';\nimport { serializeStyleSheets } from './serializeStyleSheets';\nimport { serializeAttributes } from './serializeAttributes';\nexport function serializeNodeWithId(node, parentNodePrivacyLevel, options) {\n    const serializedNode = serializeNode(node, parentNodePrivacyLevel, options);\n    if (!serializedNode) {\n        return null;\n    }\n    const id = options.scope.nodeIds.assign(node);\n    const serializedNodeWithId = serializedNode;\n    serializedNodeWithId.id = id;\n    if (options.serializedNodeIds) {\n        options.serializedNodeIds.add(id);\n    }\n    return serializedNodeWithId;\n}\nexport function serializeChildNodes(node, parentNodePrivacyLevel, options) {\n    const result = [];\n    forEachChildNodes(node, (childNode) => {\n        const serializedChildNode = serializeNodeWithId(childNode, parentNodePrivacyLevel, options);\n        if (serializedChildNode) {\n            result.push(serializedChildNode);\n        }\n    });\n    return result;\n}\nfunction serializeNode(node, parentNodePrivacyLevel, options) {\n    switch (node.nodeType) {\n        case node.DOCUMENT_NODE:\n            return serializeDocumentNode(node, parentNodePrivacyLevel, options);\n        case node.DOCUMENT_FRAGMENT_NODE:\n            return serializeDocumentFragmentNode(node, parentNodePrivacyLevel, options);\n        case node.DOCUMENT_TYPE_NODE:\n            return serializeDocumentTypeNode(node);\n        case node.ELEMENT_NODE:\n            return serializeElementNode(node, parentNodePrivacyLevel, options);\n        case node.TEXT_NODE:\n            return serializeTextNode(node, parentNodePrivacyLevel);\n        case node.CDATA_SECTION_NODE:\n            return serializeCDataNode();\n    }\n}\nexport function serializeDocumentNode(document, parentNodePrivacyLevel, options) {\n    return {\n        type: NodeType.Document,\n        childNodes: serializeChildNodes(document, parentNodePrivacyLevel, options),\n        adoptedStyleSheets: serializeStyleSheets(document.adoptedStyleSheets),\n    };\n}\nfunction serializeDocumentFragmentNode(element, parentNodePrivacyLevel, options) {\n    const isShadowRoot = isNodeShadowRoot(element);\n    if (isShadowRoot) {\n        options.serializationContext.shadowRootsController.addShadowRoot(element);\n    }\n    return {\n        type: NodeType.DocumentFragment,\n        childNodes: serializeChildNodes(element, parentNodePrivacyLevel, options),\n        isShadowRoot,\n        adoptedStyleSheets: isShadowRoot ? serializeStyleSheets(element.adoptedStyleSheets) : undefined,\n    };\n}\nfunction serializeDocumentTypeNode(documentType) {\n    return {\n        type: NodeType.DocumentType,\n        name: documentType.name,\n        publicId: documentType.publicId,\n        systemId: documentType.systemId,\n    };\n}\n/**\n * Serializing Element nodes involves capturing:\n * 1. HTML ATTRIBUTES:\n * 2. JS STATE:\n * - scroll offsets\n * - Form fields (input value, checkbox checked, option selection, range)\n * - Canvas state,\n * - Media (video/audio) play mode + currentTime\n * - iframe contents\n * - webcomponents\n * 3. CUSTOM PROPERTIES:\n * - height+width for when `hidden` to cover the element\n * 4. EXCLUDED INTERACTION STATE:\n * - focus (possible, but not worth perf impact)\n * - hover (tracked only via mouse activity)\n * - fullscreen mode\n */\nfunction serializeElementNode(element, parentNodePrivacyLevel, options) {\n    const tagName = getValidTagName(element.tagName);\n    const isSVG = isSVGElement(element) || undefined;\n    // For performance reason, we don't use getNodePrivacyLevel directly: we leverage the\n    // parentNodePrivacyLevel option to avoid iterating over all parents\n    const nodePrivacyLevel = reducePrivacyLevel(getNodeSelfPrivacyLevel(element), parentNodePrivacyLevel);\n    if (nodePrivacyLevel === NodePrivacyLevel.HIDDEN) {\n        const { width, height } = element.getBoundingClientRect();\n        return {\n            type: NodeType.Element,\n            tagName,\n            attributes: {\n                rr_width: `${width}px`,\n                rr_height: `${height}px`,\n                [PRIVACY_ATTR_NAME]: PRIVACY_ATTR_VALUE_HIDDEN,\n            },\n            childNodes: [],\n            isSVG,\n        };\n    }\n    // Ignore Elements like Script and some Link, Metas\n    if (nodePrivacyLevel === NodePrivacyLevel.IGNORE) {\n        return;\n    }\n    const attributes = serializeAttributes(element, nodePrivacyLevel, options);\n    let childNodes = [];\n    if (hasChildNodes(element) &&\n        // Do not serialize style children as the css rules are already in the _cssText attribute\n        tagName !== 'style') {\n        childNodes = serializeChildNodes(element, nodePrivacyLevel, options);\n    }\n    return {\n        type: NodeType.Element,\n        tagName,\n        attributes,\n        childNodes,\n        isSVG,\n    };\n}\nfunction isSVGElement(el) {\n    return el.tagName === 'svg' || el instanceof SVGElement;\n}\n/**\n * Text Nodes are dependant on Element nodes\n * Privacy levels are set on elements so we check the parentElement of a text node\n * for privacy level.\n */\nfunction serializeTextNode(textNode, parentNodePrivacyLevel) {\n    const textContent = getTextContent(textNode, parentNodePrivacyLevel);\n    if (textContent === undefined) {\n        return;\n    }\n    return {\n        type: NodeType.Text,\n        textContent,\n    };\n}\nfunction serializeCDataNode() {\n    return {\n        type: NodeType.CDATA,\n        textContent: '',\n    };\n}\n//# sourceMappingURL=serializeNode.js.map","import { elapsed, timeStampNow } from '@datadog/browser-core';\nimport { serializeNodeWithId } from './serializeNode';\nimport { updateSerializationStats } from './serializationStats';\nexport function serializeDocument(document, configuration, scope, serializationContext) {\n    const serializationStart = timeStampNow();\n    const serializedNode = serializeNodeWithId(document, configuration.defaultPrivacyLevel, {\n        serializationContext,\n        configuration,\n        scope,\n    });\n    updateSerializationStats(serializationContext.serializationStats, 'serializationDuration', elapsed(serializationStart, timeStampNow()));\n    // We are sure that Documents are never ignored, so this function never returns null\n    return serializedNode;\n}\n//# sourceMappingURL=serializeDocument.js.map","export function createSerializationScope(nodeIds) {\n    return { nodeIds };\n}\n//# sourceMappingURL=serializationScope.js.map","import { instrumentSetter, addEventListeners, noop } from '@datadog/browser-core';\nimport { NodePrivacyLevel, getNodePrivacyLevel, shouldMaskNode } from '@datadog/browser-rum-core';\nimport { IncrementalSource } from '../../../types';\nimport { getEventTarget } from '../eventsUtils';\nimport { getElementInputValue } from '../serialization';\nimport { assembleIncrementalSnapshot } from '../assembly';\nexport function trackInput(configuration, scope, inputCb, target = document) {\n    const defaultPrivacyLevel = configuration.defaultPrivacyLevel;\n    const lastInputStateMap = new WeakMap();\n    const isShadowRoot = target !== document;\n    const { stop: stopEventListeners } = addEventListeners(configuration, target, \n    // The 'input' event bubbles across shadow roots, so we don't have to listen for it on shadow\n    // roots since it will be handled by the event listener that we did add to the document. Only\n    // the 'change' event is blocked and needs to be handled on shadow roots.\n    isShadowRoot ? [\"change\" /* DOM_EVENT.CHANGE */] : [\"input\" /* DOM_EVENT.INPUT */, \"change\" /* DOM_EVENT.CHANGE */], (event) => {\n        const target = getEventTarget(event);\n        if (target instanceof HTMLInputElement ||\n            target instanceof HTMLTextAreaElement ||\n            target instanceof HTMLSelectElement) {\n            onElementChange(target);\n        }\n    }, {\n        capture: true,\n        passive: true,\n    });\n    let stopPropertySetterInstrumentation;\n    if (!isShadowRoot) {\n        const instrumentationStoppers = [\n            instrumentSetter(HTMLInputElement.prototype, 'value', onElementChange),\n            instrumentSetter(HTMLInputElement.prototype, 'checked', onElementChange),\n            instrumentSetter(HTMLSelectElement.prototype, 'value', onElementChange),\n            instrumentSetter(HTMLTextAreaElement.prototype, 'value', onElementChange),\n            instrumentSetter(HTMLSelectElement.prototype, 'selectedIndex', onElementChange),\n        ];\n        stopPropertySetterInstrumentation = () => {\n            instrumentationStoppers.forEach((stopper) => stopper.stop());\n        };\n    }\n    else {\n        stopPropertySetterInstrumentation = noop;\n    }\n    return {\n        stop: () => {\n            stopPropertySetterInstrumentation();\n            stopEventListeners();\n        },\n    };\n    function onElementChange(target) {\n        const nodePrivacyLevel = getNodePrivacyLevel(target, defaultPrivacyLevel);\n        if (nodePrivacyLevel === NodePrivacyLevel.HIDDEN) {\n            return;\n        }\n        const type = target.type;\n        let inputState;\n        if (type === 'radio' || type === 'checkbox') {\n            if (shouldMaskNode(target, nodePrivacyLevel)) {\n                return;\n            }\n            inputState = { isChecked: target.checked };\n        }\n        else {\n            const value = getElementInputValue(target, nodePrivacyLevel);\n            if (value === undefined) {\n                return;\n            }\n            inputState = { text: value };\n        }\n        // Can be multiple changes on the same node within the same batched mutation observation.\n        cbWithDedup(target, inputState, scope);\n        // If a radio was checked, other radios with the same name attribute will be unchecked.\n        const name = target.name;\n        if (type === 'radio' && name && target.checked) {\n            document.querySelectorAll(`input[type=\"radio\"][name=\"${CSS.escape(name)}\"]`).forEach((el) => {\n                if (el !== target) {\n                    // TODO: Consider the privacy implications for various differing input privacy levels\n                    cbWithDedup(el, { isChecked: false }, scope);\n                }\n            });\n        }\n    }\n    /**\n     * There can be multiple changes on the same node within the same batched mutation observation.\n     */\n    function cbWithDedup(target, inputState, scope) {\n        const id = scope.nodeIds.get(target);\n        if (id === undefined) {\n            return;\n        }\n        const lastInputState = lastInputStateMap.get(target);\n        if (!lastInputState ||\n            lastInputState.text !== inputState.text ||\n            lastInputState.isChecked !== inputState.isChecked) {\n            lastInputStateMap.set(target, inputState);\n            inputCb(assembleIncrementalSnapshot(IncrementalSource.Input, {\n                id,\n                ...inputState,\n            }));\n        }\n    }\n}\n//# sourceMappingURL=trackInput.js.map","import { noop, throttle, requestIdleCallback } from '@datadog/browser-core';\n/**\n * Maximum duration to wait before processing mutations. If the browser is idle, mutations will be\n * processed more quickly. If the browser is busy executing small tasks (ex: rendering frames), the\n * mutations will wait MUTATION_PROCESS_MAX_DELAY milliseconds before being processed. If the\n * browser is busy executing a longer task, mutations will be processed after this task.\n */\nconst MUTATION_PROCESS_MAX_DELAY = 100;\n/**\n * Minimum duration to wait before processing mutations. This is used to batch mutations together\n * and be able to deduplicate them to save processing time and bandwidth.\n * 16ms is the duration of a frame at 60fps that ensure fluid UI.\n */\nexport const MUTATION_PROCESS_MIN_DELAY = 16;\nexport function createMutationBatch(processMutationBatch) {\n    let cancelScheduledFlush = noop;\n    let pendingMutations = [];\n    function flush() {\n        cancelScheduledFlush();\n        processMutationBatch(pendingMutations);\n        pendingMutations = [];\n    }\n    const { throttled: throttledFlush, cancel: cancelThrottle } = throttle(flush, MUTATION_PROCESS_MIN_DELAY, {\n        leading: false,\n    });\n    return {\n        addMutations: (mutations) => {\n            if (pendingMutations.length === 0) {\n                cancelScheduledFlush = requestIdleCallback(throttledFlush, { timeout: MUTATION_PROCESS_MAX_DELAY });\n            }\n            pendingMutations.push(...mutations);\n        },\n        flush,\n        stop: () => {\n            cancelScheduledFlush();\n            cancelThrottle();\n        },\n    };\n}\n//# sourceMappingURL=mutationBatch.js.map","import { elapsed, monitor, noop, timeStampNow } from '@datadog/browser-core';\nimport { isNodeShadowHost, getMutationObserverConstructor, getParentNode, forEachChildNodes, getNodePrivacyLevel, getTextContent, NodePrivacyLevel, } from '@datadog/browser-rum-core';\nimport { IncrementalSource } from '../../../types';\nimport { getElementInputValue, serializeNodeWithId, serializeAttribute, createSerializationStats, updateSerializationStats, } from '../serialization';\nimport { createMutationBatch } from '../mutationBatch';\nimport { assembleIncrementalSnapshot } from '../assembly';\n/**\n * Buffers and aggregate mutations generated by a MutationObserver into MutationPayload\n */\nexport function trackMutation(mutationCallback, configuration, scope, shadowRootsController, target) {\n    const MutationObserver = getMutationObserverConstructor();\n    if (!MutationObserver) {\n        return { stop: noop, flush: noop };\n    }\n    const mutationBatch = createMutationBatch((mutations) => {\n        processMutations(mutations.concat(observer.takeRecords()), mutationCallback, configuration, scope, shadowRootsController);\n    });\n    const observer = new MutationObserver(monitor(mutationBatch.addMutations));\n    observer.observe(target, {\n        attributeOldValue: true,\n        attributes: true,\n        characterData: true,\n        characterDataOldValue: true,\n        childList: true,\n        subtree: true,\n    });\n    return {\n        stop: () => {\n            observer.disconnect();\n            mutationBatch.stop();\n        },\n        flush: () => {\n            mutationBatch.flush();\n        },\n    };\n}\nfunction processMutations(mutations, mutationCallback, configuration, scope, shadowRootsController) {\n    const nodePrivacyLevelCache = new Map();\n    mutations\n        .filter((mutation) => mutation.type === 'childList')\n        .forEach((mutation) => {\n        mutation.removedNodes.forEach((removedNode) => {\n            traverseRemovedShadowDom(removedNode, shadowRootsController.removeShadowRoot);\n        });\n    });\n    // Discard any mutation with a 'target' node that:\n    // * isn't injected in the current document or isn't known/serialized yet: those nodes are likely\n    // part of a mutation occurring in a parent Node\n    // * should be hidden or ignored\n    const filteredMutations = mutations.filter((mutation) => mutation.target.isConnected &&\n        scope.nodeIds.areAssignedForNodeAndAncestors(mutation.target) &&\n        getNodePrivacyLevel(mutation.target, configuration.defaultPrivacyLevel, nodePrivacyLevelCache) !==\n            NodePrivacyLevel.HIDDEN);\n    const serializationStats = createSerializationStats();\n    const { adds, removes, hasBeenSerialized } = processChildListMutations(filteredMutations.filter((mutation) => mutation.type === 'childList'), configuration, scope, serializationStats, shadowRootsController, nodePrivacyLevelCache);\n    const texts = processCharacterDataMutations(filteredMutations.filter((mutation) => mutation.type === 'characterData' && !hasBeenSerialized(mutation.target)), configuration, scope, nodePrivacyLevelCache);\n    const attributes = processAttributesMutations(filteredMutations.filter((mutation) => mutation.type === 'attributes' && !hasBeenSerialized(mutation.target)), configuration, scope, nodePrivacyLevelCache);\n    if (!texts.length && !attributes.length && !removes.length && !adds.length) {\n        return;\n    }\n    mutationCallback(assembleIncrementalSnapshot(IncrementalSource.Mutation, { adds, removes, texts, attributes }), serializationStats);\n}\nfunction processChildListMutations(mutations, configuration, scope, serializationStats, shadowRootsController, nodePrivacyLevelCache) {\n    // First, we iterate over mutations to collect:\n    //\n    // * nodes that have been added in the document and not removed by a subsequent mutation\n    // * nodes that have been removed from the document but were not added in a previous mutation\n    //\n    // For this second category, we also collect their previous parent (mutation.target) because we'll\n    // need it to emit a 'remove' mutation.\n    //\n    // Those two categories may overlap: if a node moved from a position to another, it is reported as\n    // two mutation records, one with a \"removedNodes\" and the other with \"addedNodes\". In this case,\n    // the node will be in both sets.\n    const addedAndMovedNodes = new Set();\n    const removedNodes = new Map();\n    for (const mutation of mutations) {\n        mutation.addedNodes.forEach((node) => {\n            addedAndMovedNodes.add(node);\n        });\n        mutation.removedNodes.forEach((node) => {\n            if (!addedAndMovedNodes.has(node)) {\n                removedNodes.set(node, mutation.target);\n            }\n            addedAndMovedNodes.delete(node);\n        });\n    }\n    // Then, we sort nodes that are still in the document by topological order, for two reasons:\n    //\n    // * We will serialize each added nodes with their descendants. We don't want to serialize a node\n    // twice, so we need to iterate over the parent nodes first and skip any node that is contained in\n    // a precedent node.\n    //\n    // * To emit \"add\" mutations, we need references to the parent and potential next sibling of each\n    // added node. So we need to iterate over the parent nodes first, and when multiple nodes are\n    // siblings, we want to iterate from last to first. This will ensure that any \"next\" node is\n    // already serialized and have an id.\n    const sortedAddedAndMovedNodes = Array.from(addedAndMovedNodes);\n    sortAddedAndMovedNodes(sortedAddedAndMovedNodes);\n    // Then, we iterate over our sorted node sets to emit mutations. We collect the newly serialized\n    // node ids in a set to be able to skip subsequent related mutations.\n    const serializedNodeIds = new Set();\n    const serializationContext = {\n        status: 2 /* SerializationContextStatus.MUTATION */,\n        serializationStats,\n        shadowRootsController,\n    };\n    const addedNodeMutations = [];\n    for (const node of sortedAddedAndMovedNodes) {\n        if (hasBeenSerialized(node)) {\n            continue;\n        }\n        const parentNodePrivacyLevel = getNodePrivacyLevel(node.parentNode, configuration.defaultPrivacyLevel, nodePrivacyLevelCache);\n        if (parentNodePrivacyLevel === NodePrivacyLevel.HIDDEN || parentNodePrivacyLevel === NodePrivacyLevel.IGNORE) {\n            continue;\n        }\n        const serializationStart = timeStampNow();\n        const serializedNode = serializeNodeWithId(node, parentNodePrivacyLevel, {\n            serializedNodeIds,\n            serializationContext,\n            configuration,\n            scope,\n        });\n        updateSerializationStats(serializationStats, 'serializationDuration', elapsed(serializationStart, timeStampNow()));\n        if (!serializedNode) {\n            continue;\n        }\n        const parentNode = getParentNode(node);\n        addedNodeMutations.push({\n            nextId: getNextSibling(node),\n            parentId: scope.nodeIds.get(parentNode),\n            node: serializedNode,\n        });\n    }\n    // Finally, we emit remove mutations.\n    const removedNodeMutations = [];\n    removedNodes.forEach((parent, node) => {\n        const parentId = scope.nodeIds.get(parent);\n        const id = scope.nodeIds.get(node);\n        if (parentId !== undefined && id !== undefined) {\n            removedNodeMutations.push({ parentId, id });\n        }\n    });\n    return { adds: addedNodeMutations, removes: removedNodeMutations, hasBeenSerialized };\n    function hasBeenSerialized(node) {\n        const id = scope.nodeIds.get(node);\n        return id !== undefined && serializedNodeIds.has(id);\n    }\n    function getNextSibling(node) {\n        let nextSibling = node.nextSibling;\n        while (nextSibling) {\n            const id = scope.nodeIds.get(nextSibling);\n            if (id !== undefined) {\n                return id;\n            }\n            nextSibling = nextSibling.nextSibling;\n        }\n        return null;\n    }\n}\nfunction processCharacterDataMutations(mutations, configuration, scope, nodePrivacyLevelCache) {\n    var _a;\n    const textMutations = [];\n    // Deduplicate mutations based on their target node\n    const handledNodes = new Set();\n    const filteredMutations = mutations.filter((mutation) => {\n        if (handledNodes.has(mutation.target)) {\n            return false;\n        }\n        handledNodes.add(mutation.target);\n        return true;\n    });\n    // Emit mutations\n    for (const mutation of filteredMutations) {\n        const value = mutation.target.textContent;\n        if (value === mutation.oldValue) {\n            continue;\n        }\n        const id = scope.nodeIds.get(mutation.target);\n        if (id === undefined) {\n            continue;\n        }\n        const parentNodePrivacyLevel = getNodePrivacyLevel(getParentNode(mutation.target), configuration.defaultPrivacyLevel, nodePrivacyLevelCache);\n        if (parentNodePrivacyLevel === NodePrivacyLevel.HIDDEN || parentNodePrivacyLevel === NodePrivacyLevel.IGNORE) {\n            continue;\n        }\n        textMutations.push({\n            id,\n            value: (_a = getTextContent(mutation.target, parentNodePrivacyLevel)) !== null && _a !== void 0 ? _a : null,\n        });\n    }\n    return textMutations;\n}\nfunction processAttributesMutations(mutations, configuration, scope, nodePrivacyLevelCache) {\n    const attributeMutations = [];\n    // Deduplicate mutations based on their target node and changed attribute\n    const handledElements = new Map();\n    const filteredMutations = mutations.filter((mutation) => {\n        const handledAttributes = handledElements.get(mutation.target);\n        if (handledAttributes && handledAttributes.has(mutation.attributeName)) {\n            return false;\n        }\n        if (!handledAttributes) {\n            handledElements.set(mutation.target, new Set([mutation.attributeName]));\n        }\n        else {\n            handledAttributes.add(mutation.attributeName);\n        }\n        return true;\n    });\n    // Emit mutations\n    const emittedMutations = new Map();\n    for (const mutation of filteredMutations) {\n        const uncensoredValue = mutation.target.getAttribute(mutation.attributeName);\n        if (uncensoredValue === mutation.oldValue) {\n            continue;\n        }\n        const id = scope.nodeIds.get(mutation.target);\n        if (id === undefined) {\n            continue;\n        }\n        const privacyLevel = getNodePrivacyLevel(mutation.target, configuration.defaultPrivacyLevel, nodePrivacyLevelCache);\n        const attributeValue = serializeAttribute(mutation.target, privacyLevel, mutation.attributeName, configuration);\n        let transformedValue;\n        if (mutation.attributeName === 'value') {\n            const inputValue = getElementInputValue(mutation.target, privacyLevel);\n            if (inputValue === undefined) {\n                continue;\n            }\n            transformedValue = inputValue;\n        }\n        else if (typeof attributeValue === 'string') {\n            transformedValue = attributeValue;\n        }\n        else {\n            transformedValue = null;\n        }\n        let emittedMutation = emittedMutations.get(mutation.target);\n        if (!emittedMutation) {\n            emittedMutation = { id, attributes: {} };\n            attributeMutations.push(emittedMutation);\n            emittedMutations.set(mutation.target, emittedMutation);\n        }\n        emittedMutation.attributes[mutation.attributeName] = transformedValue;\n    }\n    return attributeMutations;\n}\nexport function sortAddedAndMovedNodes(nodes) {\n    nodes.sort((a, b) => {\n        const position = a.compareDocumentPosition(b);\n        /* eslint-disable no-bitwise */\n        if (position & Node.DOCUMENT_POSITION_CONTAINED_BY) {\n            return -1;\n        }\n        else if (position & Node.DOCUMENT_POSITION_CONTAINS) {\n            return 1;\n        }\n        else if (position & Node.DOCUMENT_POSITION_FOLLOWING) {\n            return 1;\n        }\n        else if (position & Node.DOCUMENT_POSITION_PRECEDING) {\n            return -1;\n        }\n        /* eslint-enable no-bitwise */\n        return 0;\n    });\n}\nfunction traverseRemovedShadowDom(removedNode, shadowDomRemovedCallback) {\n    if (isNodeShadowHost(removedNode)) {\n        shadowDomRemovedCallback(removedNode.shadowRoot);\n    }\n    forEachChildNodes(removedNode, (childNode) => traverseRemovedShadowDom(childNode, shadowDomRemovedCallback));\n}\n//# sourceMappingURL=trackMutation.js.map","export function createElementsScrollPositions() {\n    const scrollPositionsByElement = new WeakMap();\n    return {\n        set(element, scrollPositions) {\n            if (element === document && !document.scrollingElement) {\n                // cf https://drafts.csswg.org/cssom-view/#dom-document-scrollingelement,\n                // in some cases scrolling elements can not be defined, we don't support those for now\n                return;\n            }\n            scrollPositionsByElement.set(element === document ? document.scrollingElement : element, scrollPositions);\n        },\n        get(element) {\n            return scrollPositionsByElement.get(element);\n        },\n        has(element) {\n            return scrollPositionsByElement.has(element);\n        },\n    };\n}\n//# sourceMappingURL=elementsScrollPositions.js.map","import { trackInput, trackMutation, trackScroll } from './trackers';\nexport const initShadowRootsController = (configuration, scope, callback, elementsScrollPositions) => {\n    const controllerByShadowRoot = new Map();\n    const shadowRootsController = {\n        addShadowRoot: (shadowRoot) => {\n            if (controllerByShadowRoot.has(shadowRoot)) {\n                return;\n            }\n            const mutationTracker = trackMutation(callback, configuration, scope, shadowRootsController, shadowRoot);\n            // The change event does not bubble up across the shadow root, we have to listen on the shadow root\n            const inputTracker = trackInput(configuration, scope, callback, shadowRoot);\n            // The scroll event does not bubble up across the shadow root, we have to listen on the shadow root\n            const scrollTracker = trackScroll(configuration, scope, callback, elementsScrollPositions, shadowRoot);\n            controllerByShadowRoot.set(shadowRoot, {\n                flush: () => mutationTracker.flush(),\n                stop: () => {\n                    mutationTracker.stop();\n                    inputTracker.stop();\n                    scrollTracker.stop();\n                },\n            });\n        },\n        removeShadowRoot: (shadowRoot) => {\n            const entry = controllerByShadowRoot.get(shadowRoot);\n            if (!entry) {\n                // unidentified root cause: observed in some cases with shadow DOM added by browser extensions\n                return;\n            }\n            entry.stop();\n            controllerByShadowRoot.delete(shadowRoot);\n        },\n        stop: () => {\n            controllerByShadowRoot.forEach(({ stop }) => stop());\n        },\n        flush: () => {\n            controllerByShadowRoot.forEach(({ flush }) => flush());\n        },\n    };\n    return shadowRootsController;\n};\n//# sourceMappingURL=shadowRootsController.js.map","import { getScrollX, getScrollY, getViewportDimension } from '@datadog/browser-rum-core';\nimport { timeStampNow } from '@datadog/browser-core';\nimport { RecordType } from '../../types';\nimport { createSerializationStats, serializeDocument } from './serialization';\nimport { getVisualViewport } from './viewports';\nexport function startFullSnapshots(elementsScrollPositions, shadowRootsController, lifeCycle, configuration, scope, flushMutations, emit) {\n    const takeFullSnapshot = (timestamp, status) => {\n        const { width, height } = getViewportDimension();\n        emit({\n            data: {\n                height,\n                href: window.location.href,\n                width,\n            },\n            type: RecordType.Meta,\n            timestamp,\n        });\n        emit({\n            data: {\n                has_focus: document.hasFocus(),\n            },\n            type: RecordType.Focus,\n            timestamp,\n        });\n        const serializationStats = createSerializationStats();\n        const serializationContext = {\n            status,\n            elementsScrollPositions,\n            serializationStats,\n            shadowRootsController,\n        };\n        emit({\n            data: {\n                node: serializeDocument(document, configuration, scope, serializationContext),\n                initialOffset: {\n                    left: getScrollX(),\n                    top: getScrollY(),\n                },\n            },\n            type: RecordType.FullSnapshot,\n            timestamp,\n        }, serializationStats);\n        if (window.visualViewport) {\n            emit({\n                data: getVisualViewport(window.visualViewport),\n                type: RecordType.VisualViewport,\n                timestamp,\n            });\n        }\n    };\n    takeFullSnapshot(timeStampNow(), 0 /* SerializationContextStatus.INITIAL_FULL_SNAPSHOT */);\n    const { unsubscribe } = lifeCycle.subscribe(2 /* LifeCycleEventType.VIEW_CREATED */, (view) => {\n        flushMutations();\n        takeFullSnapshot(view.startClocks.timeStamp, 1 /* SerializationContextStatus.SUBSEQUENT_FULL_SNAPSHOT */);\n    });\n    return {\n        stop: unsubscribe,\n    };\n}\n//# sourceMappingURL=startFullSnapshots.js.map","export function initRecordIds() {\n    const recordIds = new WeakMap();\n    let nextId = 1;\n    return {\n        getIdForEvent(event) {\n            if (!recordIds.has(event)) {\n                recordIds.set(event, nextId++);\n            }\n            return recordIds.get(event);\n        },\n    };\n}\n//# sourceMappingURL=recordIds.js.map","import { getParentNode, isNodeShadowRoot } from '@datadog/browser-rum-core';\nexport function createNodeIds() {\n    const nodeIds = new WeakMap();\n    let nextNodeId = 1 /* NodeIdConstants.FIRST_ID */;\n    const get = (node) => nodeIds.get(node);\n    return {\n        assign: (node) => {\n            // Try to reuse any existing id.\n            let nodeId = get(node);\n            if (nodeId === undefined) {\n                nodeId = nextNodeId++;\n                nodeIds.set(node, nodeId);\n            }\n            return nodeId;\n        },\n        get,\n        areAssignedForNodeAndAncestors: (node) => {\n            let current = node;\n            while (current) {\n                if (get(current) === undefined && !isNodeShadowRoot(current)) {\n                    return false;\n                }\n                current = getParentNode(current);\n            }\n            return true;\n        },\n    };\n}\n//# sourceMappingURL=nodeIds.js.map","import { sendToExtension } from '@datadog/browser-core';\nimport * as replayStats from '../replayStats';\nimport { trackFocus, trackFrustration, trackInput, trackMediaInteraction, trackMouseInteraction, trackMove, trackMutation, trackScroll, trackStyleSheet, trackViewEnd, trackViewportResize, trackVisualViewportResize, } from './trackers';\nimport { createElementsScrollPositions } from './elementsScrollPositions';\nimport { initShadowRootsController } from './shadowRootsController';\nimport { startFullSnapshots } from './startFullSnapshots';\nimport { initRecordIds } from './recordIds';\nimport { createSerializationScope } from './serialization';\nimport { createNodeIds } from './nodeIds';\nexport function record(options) {\n    const { emit, configuration, lifeCycle } = options;\n    // runtime checks for user options\n    if (!emit) {\n        throw new Error('emit function is required');\n    }\n    const emitAndComputeStats = (record, stats) => {\n        emit(record, stats);\n        sendToExtension('record', { record });\n        const view = options.viewHistory.findView();\n        replayStats.addRecord(view.id);\n    };\n    const elementsScrollPositions = createElementsScrollPositions();\n    const scope = createSerializationScope(createNodeIds());\n    const shadowRootsController = initShadowRootsController(configuration, scope, emitAndComputeStats, elementsScrollPositions);\n    const { stop: stopFullSnapshots } = startFullSnapshots(elementsScrollPositions, shadowRootsController, lifeCycle, configuration, scope, flushMutations, emitAndComputeStats);\n    function flushMutations() {\n        shadowRootsController.flush();\n        mutationTracker.flush();\n    }\n    const recordIds = initRecordIds();\n    const mutationTracker = trackMutation(emitAndComputeStats, configuration, scope, shadowRootsController, document);\n    const trackers = [\n        mutationTracker,\n        trackMove(configuration, scope, emitAndComputeStats),\n        trackMouseInteraction(configuration, scope, emitAndComputeStats, recordIds),\n        trackScroll(configuration, scope, emitAndComputeStats, elementsScrollPositions, document),\n        trackViewportResize(configuration, emitAndComputeStats),\n        trackInput(configuration, scope, emitAndComputeStats),\n        trackMediaInteraction(configuration, scope, emitAndComputeStats),\n        trackStyleSheet(scope, emitAndComputeStats),\n        trackFocus(configuration, emitAndComputeStats),\n        trackVisualViewportResize(configuration, emitAndComputeStats),\n        trackFrustration(lifeCycle, emitAndComputeStats, recordIds),\n        trackViewEnd(lifeCycle, (viewEndRecord) => {\n            flushMutations();\n            emitAndComputeStats(viewEndRecord);\n        }),\n    ];\n    return {\n        stop: () => {\n            shadowRootsController.stop();\n            trackers.forEach((tracker) => tracker.stop());\n            stopFullSnapshots();\n        },\n        flushMutations,\n        shadowRootsController,\n    };\n}\n//# sourceMappingURL=record.js.map","export function buildReplayPayload(data, metadata, stats, rawSegmentBytesCount) {\n    const formData = new FormData();\n    formData.append('segment', new Blob([data], {\n        type: 'application/octet-stream',\n    }), `${metadata.session.id}-${metadata.start}`);\n    const metadataAndSegmentSizes = {\n        raw_segment_size: rawSegmentBytesCount,\n        compressed_segment_size: data.byteLength,\n        ...metadata,\n    };\n    const serializedMetadataAndSegmentSizes = JSON.stringify(metadataAndSegmentSizes);\n    formData.append('event', new Blob([serializedMetadataAndSegmentSizes], { type: 'application/json' }));\n    return {\n        data: formData,\n        bytesCount: data.byteLength,\n        cssText: stats.cssText,\n        isFullSnapshot: metadata.index_in_view === 0,\n        rawSize: rawSegmentBytesCount,\n        recordCount: metadata.records_count,\n        serializationDuration: stats.serializationDuration,\n    };\n}\n//# sourceMappingURL=buildReplayPayload.js.map","import { RecordType } from '../../types';\nimport * as replayStats from '../replayStats';\nimport { aggregateSerializationStats, createSerializationStats } from '../record';\nexport function createSegment({ context, creationReason, encoder, }) {\n    let encodedBytesCount = 0;\n    const viewId = context.view.id;\n    const indexInView = replayStats.getSegmentsCount(viewId);\n    const metadata = {\n        start: Infinity,\n        end: -Infinity,\n        creation_reason: creationReason,\n        records_count: 0,\n        has_full_snapshot: false,\n        index_in_view: indexInView,\n        source: 'browser',\n        ...context,\n    };\n    const serializationStats = createSerializationStats();\n    replayStats.addSegment(viewId);\n    function addRecord(record, stats, callback) {\n        metadata.start = Math.min(metadata.start, record.timestamp);\n        metadata.end = Math.max(metadata.end, record.timestamp);\n        metadata.records_count += 1;\n        metadata.has_full_snapshot || (metadata.has_full_snapshot = record.type === RecordType.FullSnapshot);\n        if (stats) {\n            aggregateSerializationStats(serializationStats, stats);\n        }\n        const prefix = encoder.isEmpty ? '{\"records\":[' : ',';\n        encoder.write(prefix + JSON.stringify(record), (additionalEncodedBytesCount) => {\n            encodedBytesCount += additionalEncodedBytesCount;\n            callback(encodedBytesCount);\n        });\n    }\n    function flush(callback) {\n        if (encoder.isEmpty) {\n            throw new Error('Empty segment flushed');\n        }\n        encoder.write(`],${JSON.stringify(metadata).slice(1)}\\n`);\n        encoder.finish((encoderResult) => {\n            replayStats.addWroteData(metadata.view.id, encoderResult.rawBytesCount);\n            callback(metadata, serializationStats, encoderResult);\n        });\n    }\n    return { addRecord, flush };\n}\n//# sourceMappingURL=segment.js.map","import { isPageExitReason, ONE_SECOND, clearTimeout, setTimeout } from '@datadog/browser-core';\nimport { buildReplayPayload } from './buildReplayPayload';\nimport { createSegment } from './segment';\nexport const SEGMENT_DURATION_LIMIT = 5 * ONE_SECOND;\n/**\n * beacon payload max queue size implementation is 64kb\n * ensure that we leave room for logs, rum and potential other users\n */\nexport let SEGMENT_BYTES_LIMIT = 60000;\nexport function startSegmentCollection(lifeCycle, configuration, sessionManager, viewHistory, httpRequest, encoder) {\n    return doStartSegmentCollection(lifeCycle, () => computeSegmentContext(configuration.applicationId, sessionManager, viewHistory), httpRequest, encoder);\n}\nexport function doStartSegmentCollection(lifeCycle, getSegmentContext, httpRequest, encoder) {\n    let state = {\n        status: 0 /* SegmentCollectionStatus.WaitingForInitialRecord */,\n        nextSegmentCreationReason: 'init',\n    };\n    const { unsubscribe: unsubscribeViewCreated } = lifeCycle.subscribe(2 /* LifeCycleEventType.VIEW_CREATED */, () => {\n        flushSegment('view_change');\n    });\n    const { unsubscribe: unsubscribePageMayExit } = lifeCycle.subscribe(11 /* LifeCycleEventType.PAGE_MAY_EXIT */, (pageMayExitEvent) => {\n        flushSegment(pageMayExitEvent.reason);\n    });\n    function flushSegment(flushReason) {\n        if (state.status === 1 /* SegmentCollectionStatus.SegmentPending */) {\n            state.segment.flush((metadata, stats, encoderResult) => {\n                const payload = buildReplayPayload(encoderResult.output, metadata, stats, encoderResult.rawBytesCount);\n                if (isPageExitReason(flushReason)) {\n                    httpRequest.sendOnExit(payload);\n                }\n                else {\n                    httpRequest.send(payload);\n                }\n            });\n            clearTimeout(state.expirationTimeoutId);\n        }\n        if (flushReason !== 'stop') {\n            state = {\n                status: 0 /* SegmentCollectionStatus.WaitingForInitialRecord */,\n                nextSegmentCreationReason: flushReason,\n            };\n        }\n        else {\n            state = {\n                status: 2 /* SegmentCollectionStatus.Stopped */,\n            };\n        }\n    }\n    return {\n        addRecord: (record, stats) => {\n            if (state.status === 2 /* SegmentCollectionStatus.Stopped */) {\n                return;\n            }\n            if (state.status === 0 /* SegmentCollectionStatus.WaitingForInitialRecord */) {\n                const context = getSegmentContext();\n                if (!context) {\n                    return;\n                }\n                state = {\n                    status: 1 /* SegmentCollectionStatus.SegmentPending */,\n                    segment: createSegment({ encoder, context, creationReason: state.nextSegmentCreationReason }),\n                    expirationTimeoutId: setTimeout(() => {\n                        flushSegment('segment_duration_limit');\n                    }, SEGMENT_DURATION_LIMIT),\n                };\n            }\n            state.segment.addRecord(record, stats, (encodedBytesCount) => {\n                if (encodedBytesCount > SEGMENT_BYTES_LIMIT) {\n                    flushSegment('segment_bytes_limit');\n                }\n            });\n        },\n        stop: () => {\n            flushSegment('stop');\n            unsubscribeViewCreated();\n            unsubscribePageMayExit();\n        },\n    };\n}\nexport function computeSegmentContext(applicationId, sessionManager, viewHistory) {\n    const session = sessionManager.findTrackedSession();\n    const viewContext = viewHistory.findView();\n    if (!session || !viewContext) {\n        return undefined;\n    }\n    return {\n        application: {\n            id: applicationId,\n        },\n        session: {\n            id: session.id,\n        },\n        view: {\n            id: viewContext.id,\n        },\n    };\n}\nexport function setSegmentBytesLimit(newSegmentBytesLimit = 60000) {\n    SEGMENT_BYTES_LIMIT = newSegmentBytesLimit;\n}\n//# sourceMappingURL=segmentCollection.js.map","import { addTelemetryMetrics, noop } from '@datadog/browser-core';\nexport function startSegmentTelemetry(telemetry, requestObservable) {\n    if (!telemetry.metricsEnabled) {\n        return { stop: noop };\n    }\n    const { unsubscribe } = requestObservable.subscribe((requestEvent) => {\n        if (requestEvent.type === 'failure' ||\n            requestEvent.type === 'queue-full' ||\n            (requestEvent.type === 'success' && requestEvent.payload.isFullSnapshot)) {\n            const metrics = createSegmentMetrics(requestEvent.type, requestEvent.bandwidth, requestEvent.payload);\n            // monitor-until: 2026-07-01\n            addTelemetryMetrics(\"Segment network request metrics\" /* TelemetryMetrics.SEGMENT_METRICS_TELEMETRY_NAME */, { metrics });\n        }\n    });\n    return {\n        stop: unsubscribe,\n    };\n}\nfunction createSegmentMetrics(result, bandwidthStats, payload) {\n    return {\n        cssText: {\n            count: payload.cssText.count,\n            max: payload.cssText.max,\n            sum: payload.cssText.sum,\n        },\n        isFullSnapshot: payload.isFullSnapshot,\n        ongoingRequests: {\n            count: bandwidthStats.ongoingRequestCount,\n            totalSize: bandwidthStats.ongoingByteCount,\n        },\n        recordCount: payload.recordCount,\n        result,\n        serializationDuration: {\n            count: payload.serializationDuration.count,\n            max: payload.serializationDuration.max,\n            sum: payload.serializationDuration.sum,\n        },\n        size: {\n            compressed: payload.bytesCount,\n            raw: payload.rawSize,\n        },\n    };\n}\n//# sourceMappingURL=startSegmentTelemetry.js.map","import { getEventBridge } from '@datadog/browser-core';\nexport function startRecordBridge(viewHistory) {\n    const bridge = getEventBridge();\n    return {\n        addRecord: (record) => {\n            // Get the current active view, not at the time of the record, aligning with the segment logic.\n            // This approach could potentially associate the record to an incorrect view, in case the record date is in the past (e.g. frustration records).\n            // However the risk is minimal. We could address the issue when potential negative impact are identified.\n            const view = viewHistory.findView();\n            bridge.send('record', record, view.id);\n        },\n    };\n}\n//# sourceMappingURL=startRecordBridge.js.map","import { createHttpRequest, addTelemetryDebug, canUseEventBridge } from '@datadog/browser-core';\nimport { record } from '../domain/record';\nimport { startSegmentCollection, SEGMENT_BYTES_LIMIT, startSegmentTelemetry } from '../domain/segmentCollection';\nimport { startRecordBridge } from '../domain/startRecordBridge';\nexport function startRecording(lifeCycle, configuration, sessionManager, viewHistory, encoder, telemetry, httpRequest) {\n    const cleanupTasks = [];\n    const reportError = (error) => {\n        lifeCycle.notify(14 /* LifeCycleEventType.RAW_ERROR_COLLECTED */, { error });\n        // monitor-until: forever, to keep an eye on the errors reported to customers\n        addTelemetryDebug('Error reported to customer', { 'error.message': error.message });\n    };\n    const replayRequest = httpRequest || createHttpRequest([configuration.sessionReplayEndpointBuilder], reportError, SEGMENT_BYTES_LIMIT);\n    let addRecord;\n    if (!canUseEventBridge()) {\n        const segmentCollection = startSegmentCollection(lifeCycle, configuration, sessionManager, viewHistory, replayRequest, encoder);\n        addRecord = segmentCollection.addRecord;\n        cleanupTasks.push(segmentCollection.stop);\n        const segmentTelemetry = startSegmentTelemetry(telemetry, replayRequest.observable);\n        cleanupTasks.push(segmentTelemetry.stop);\n    }\n    else {\n        ;\n        ({ addRecord } = startRecordBridge(viewHistory));\n    }\n    const { stop: stopRecording } = record({\n        emit: addRecord,\n        configuration,\n        lifeCycle,\n        viewHistory,\n    });\n    cleanupTasks.push(stopRecording);\n    return {\n        stop: () => {\n            cleanupTasks.forEach((task) => task());\n        },\n    };\n}\n//# sourceMappingURL=startRecording.js.map"],"names":["RecordType","NodeType","IncrementalSource","MouseInteractionType","MediaInteractionType","isTouchEvent","event","getEventTarget","isNodeShadowHost","TOLERANCE","isVisualViewportFactoredIn","visualViewport","convertMouseEventToLayoutCoordinates","clientX","clientY","normalized","getVisualViewport","assembleIncrementalSnapshot","source","data","timeStampNow","MOUSE_MOVE_OBSERVER_THRESHOLD","trackMove","configuration","scope","moveCb","updatePosition","cancelThrottle","throttle","target","id","coordinates","tryToComputeCoordinates","position","removeListener","addEventListeners","x","y","visualViewportX","visualViewportY","eventTypeToMouseInteraction","trackMouseInteraction","mouseInteractionCb","recordIds","handler","getNodePrivacyLevel","NodePrivacyLevel","type","interaction","record","SCROLL_OBSERVER_THRESHOLD","trackScroll","scrollCb","elementsScrollPositions","scrollPositions","getScrollY","getScrollX","addEventListener","VISUAL_VIEWPORT_OBSERVER_THRESHOLD","trackViewportResize","viewportResizeCb","viewportResizeSubscription","initViewportObservable","trackVisualViewportResize","visualViewportResizeCb","noop","updateDimension","trackMediaInteraction","mediaInteractionCb","trackStyleSheet","styleSheetCb","checkStyleSheetAndCallback","styleSheet","callback","instrumentationStoppers","instrumentMethod","rule","index","instrumentGroupingCSSRuleClass","cls","path","getPathToNestedCSSRule","stopper","currentRule","trackFocus","focusCb","trackFrustration","lifeCycle","frustrationCb","frustrationSubscription","_a","_b","RumEventType","ActionType","e","trackViewEnd","viewEndCb","viewEndSubscription","getElementInputValue","element","nodePrivacyLevel","tagName","value","shouldMaskNode","CENSORED_STRING_MARK","URL_IN_CSS_REF","ABSOLUTE_URL","DATA_URI","switchToAbsoluteUrl","cssText","cssHref","matchingSubstring","singleQuote","urlWrappedInSingleQuotes","doubleQuote","urlWrappedInDoubleQuotes","urlNotWrappedInQuotes","url","quote","makeUrlAbsolute","baseUrl","buildUrl","TAG_NAME_REGEX","getValidTagName","processedTagName","censoredImageForSize","width","height","serializeStyleSheets","cssStyleSheets","cssStyleSheet","rules","cssRule","MAX_ATTRIBUTE_VALUE_CHAR_LENGTH","serializeAttribute","attributeName","attributeValue","shouldMaskAttribute","image","CENSORED_IMG_MARK","sanitizeIfLongDataUrl","createSerializationStats","updateSerializationStats","stats","metric","aggregateSerializationStats","aggregateStats","serializeAttributes","options","safeAttrs","doc","i","formValue","optionElement","stylesheet","s","getCssRulesString","inputElement","mediaElement","scrollTop","scrollLeft","serializationContext","styleSheetCssText","isSafari","getCssRuleStringForSafari","getCssRuleString","isCSSStyleRule","escapeColon","isCSSImportRule","serializeNodeWithId","node","parentNodePrivacyLevel","serializedNode","serializeNode","serializedNodeWithId","serializeChildNodes","result","forEachChildNodes","childNode","serializedChildNode","serializeDocumentNode","serializeDocumentFragmentNode","serializeDocumentTypeNode","serializeElementNode","serializeTextNode","serializeCDataNode","document","isShadowRoot","isNodeShadowRoot","documentType","isSVG","isSVGElement","reducePrivacyLevel","getNodeSelfPrivacyLevel","PRIVACY_ATTR_NAME","PRIVACY_ATTR_VALUE_HIDDEN","attributes","childNodes","hasChildNodes","el","textNode","textContent","getTextContent","serializeDocument","serializationStart","elapsed","createSerializationScope","nodeIds","trackInput","inputCb","defaultPrivacyLevel","lastInputStateMap","stopEventListeners","onElementChange","stopPropertySetterInstrumentation","instrumentSetter","inputState","cbWithDedup","name","lastInputState","MUTATION_PROCESS_MAX_DELAY","MUTATION_PROCESS_MIN_DELAY","createMutationBatch","processMutationBatch","cancelScheduledFlush","pendingMutations","flush","throttledFlush","mutations","requestIdleCallback","trackMutation","mutationCallback","shadowRootsController","MutationObserver","getMutationObserverConstructor","mutationBatch","processMutations","observer","monitor","nodePrivacyLevelCache","mutation","removedNode","traverseRemovedShadowDom","filteredMutations","serializationStats","adds","removes","hasBeenSerialized","processChildListMutations","texts","processCharacterDataMutations","processAttributesMutations","addedAndMovedNodes","removedNodes","sortedAddedAndMovedNodes","sortAddedAndMovedNodes","serializedNodeIds","addedNodeMutations","parentNode","getParentNode","getNextSibling","removedNodeMutations","parent","parentId","nextSibling","textMutations","handledNodes","attributeMutations","handledElements","handledAttributes","emittedMutations","privacyLevel","transformedValue","inputValue","emittedMutation","nodes","a","b","shadowDomRemovedCallback","createElementsScrollPositions","scrollPositionsByElement","initShadowRootsController","controllerByShadowRoot","shadowRoot","mutationTracker","inputTracker","scrollTracker","entry","stop","startFullSnapshots","flushMutations","emit","takeFullSnapshot","timestamp","status","getViewportDimension","unsubscribe","view","initRecordIds","nextId","createNodeIds","nextNodeId","get","nodeId","current","emitAndComputeStats","sendToExtension","replayStats.addRecord","stopFullSnapshots","trackers","viewEndRecord","tracker","buildReplayPayload","metadata","rawSegmentBytesCount","formData","metadataAndSegmentSizes","serializedMetadataAndSegmentSizes","createSegment","context","creationReason","encoder","encodedBytesCount","viewId","indexInView","replayStats.getSegmentsCount","replayStats.addSegment","addRecord","prefix","additionalEncodedBytesCount","encoderResult","replayStats.addWroteData","SEGMENT_DURATION_LIMIT","ONE_SECOND","SEGMENT_BYTES_LIMIT","startSegmentCollection","sessionManager","viewHistory","httpRequest","doStartSegmentCollection","computeSegmentContext","getSegmentContext","state","unsubscribeViewCreated","flushSegment","unsubscribePageMayExit","pageMayExitEvent","flushReason","payload","isPageExitReason","clearTimeout","setTimeout","applicationId","session","viewContext","startSegmentTelemetry","telemetry","requestObservable","requestEvent","metrics","createSegmentMetrics","addTelemetryMetrics","bandwidthStats","startRecordBridge","bridge","getEventBridge","startRecording","cleanupTasks","reportError","error","addTelemetryDebug","replayRequest","createHttpRequest","canUseEventBridge","segmentCollection","segmentTelemetry","stopRecording","task"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35]}