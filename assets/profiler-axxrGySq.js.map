{"version":3,"file":"profiler-axxrGySq.js","sources":["../../../../node_modules/@datadog/browser-rum/esm/domain/profiling/utils/getNumberOfSamples.js","../../../../node_modules/@datadog/browser-rum/esm/domain/profiling/utils/longTaskRegistry.js","../../../../node_modules/@datadog/browser-rum/esm/domain/profiling/profilingCorrelation.js","../../../../node_modules/@datadog/browser-rum/esm/domain/profiling/transport/transport.js","../../../../node_modules/@datadog/browser-rum/esm/domain/profiling/profiler.js"],"sourcesContent":["/**\n * Counts number of samples when the thread was not idle (stackId is defined)\n * @param samples Array of collected samples\n * @returns Number of samples\n */\nexport function getNumberOfSamples(samples) {\n    let numberOfSamples = 0;\n    for (const sample of samples) {\n        if (sample.stackId !== undefined) {\n            numberOfSamples++;\n        }\n    }\n    return numberOfSamples;\n}\n//# sourceMappingURL=getNumberOfSamples.js.map","// Maps PerformanceEntry start-time to the corresponding long task id (from RUM LongTaskEvent),\n// We need this to link RUM Long Tasks with RUM Profiler stack traces\n// Given that long task takes at least 50ms and we export profile at least every 60 seconds, we can have up to 1200 entries (60s / 50ms = 1200).\nconst registry = new Map();\nexport function disableLongTaskRegistry() {\n    registry.clear(); // Free-up the memory\n}\n/**\n * Store the long task ID in the registry for the Profiler to link it with the corresponding Profile.\n */\nexport function setLongTaskId(longTaskId, startTime) {\n    registry.set(startTime, longTaskId);\n}\nexport function getLongTaskId(startTime) {\n    return registry.get(startTime);\n}\n/**\n * Delete the Long Task from the registry once we have collected it.\n *\n * @param collectionRelativeTime The relative time of the collection\n */\nexport function cleanupLongTaskRegistryAfterCollection(collectionRelativeTime) {\n    for (const performanceStartTime of registry.keys()) {\n        if (performanceStartTime < collectionRelativeTime) {\n            // We collected this Long Task already, no need to keep it in the registry.\n            registry.delete(performanceStartTime);\n        }\n    }\n}\n//# sourceMappingURL=longTaskRegistry.js.map","import { setLongTaskId } from './utils/longTaskRegistry';\n/**\n * Store the Long Task ID in the registry for the Profiler to link it with the corresponding Profile.\n *\n * @param rawRumEvent The Raw RUM event\n * @param startTime The start time of the event (in this case the Long Task Performance Entry start time)\n */\nexport function mayStoreLongTaskIdForProfilerCorrelation({ rawRumEvent, startTime, }) {\n    if (rawRumEvent.type !== \"long_task\" /* RumEventType.LONG_TASK */) {\n        return;\n    }\n    const longTaskId = rawRumEvent.long_task.id;\n    // Store longTaskId in the registry for the Profiler to link it with the corresponding Profile.\n    setLongTaskId(longTaskId, startTime);\n}\n//# sourceMappingURL=profilingCorrelation.js.map","import { addTelemetryDebug, currentDrift } from '@datadog/browser-core';\n/**\n * Send RUM profile as JSON to public profiling intake.\n */\nconst sendProfile = (profilerTrace, endpointBuilder, applicationId, sessionId) => {\n    const event = buildProfileEvent(profilerTrace, endpointBuilder, applicationId, sessionId);\n    const payload = buildProfilingPayload(profilerTrace, event);\n    // Create URL, public profiling intake.\n    const profilingIntakeURL = endpointBuilder.build('fetch', payload);\n    addTelemetryDebug('Sending profile to public profiling intake', { profilingIntakeURL, applicationId, sessionId });\n    // Send payload (event + profile as attachment).\n    return fetch(profilingIntakeURL, {\n        body: payload.data,\n        method: 'POST',\n    });\n};\nfunction buildProfileEvent(profilerTrace, endpointBuilder, applicationId, sessionId) {\n    const tags = endpointBuilder.tags;\n    const profileAttributes = buildProfileEventAttributes(profilerTrace, applicationId, sessionId);\n    const profileEventTags = buildProfileEventTags(tags);\n    const profileEvent = {\n        ...profileAttributes,\n        attachments: ['wall-time.json'],\n        start: new Date(profilerTrace.startClocks.timeStamp).toISOString(),\n        end: new Date(profilerTrace.endClocks.timeStamp).toISOString(),\n        family: 'chrome',\n        runtime: 'chrome',\n        format: 'json',\n        version: 4, // Ingestion event version (not the version application tag)\n        tags_profiler: profileEventTags.join(','),\n        _dd: {\n            clock_drift: currentDrift(),\n        },\n    };\n    return profileEvent;\n}\n/**\n * Builds tags for the Profile Event.\n * @param tags RUM tags\n * @returns Combined tags for the Profile Event.\n */\nfunction buildProfileEventTags(tags) {\n    // Tags already contains the common tags for all events. (service, env, version, etc.)\n    // Here we are adding some specific-to-profiling tags.\n    const profileEventTags = tags.concat(['language:javascript', 'runtime:chrome', 'family:chrome', 'host:browser']);\n    return profileEventTags;\n}\n/**\n * Builds payload for Profiling intake. It includes the profile event and the profiler trace as attachment.\n * @param profilerTrace Profiler trace\n * @param profileEvent Profiling event.\n * @returns Payload to be sent to the intake.\n */\nfunction buildProfilingPayload(profilerTrace, profileEvent) {\n    const profilerTraceBlob = new Blob([JSON.stringify(profilerTrace)], {\n        type: 'application/json',\n    });\n    const formData = new FormData();\n    formData.append('event', new Blob([JSON.stringify(profileEvent)], { type: 'application/json' }), 'event.json');\n    formData.append('wall-time.json', profilerTraceBlob, 'wall-time.json');\n    return { data: formData, bytesCount: 0 };\n}\n/**\n * Builds attributes for the Profile Event.\n * @param profilerTrace Profiler trace\n * @param applicationId application id.\n * @param sessionId session id.\n * @returns Additional attributes.\n */\nfunction buildProfileEventAttributes(profilerTrace, applicationId, sessionId) {\n    const attributes = {\n        application: {\n            id: applicationId,\n        },\n    };\n    if (sessionId) {\n        attributes.session = {\n            id: sessionId,\n        };\n    }\n    const viewIds = Array.from(new Set(profilerTrace.views.map((viewEntry) => viewEntry.viewId)));\n    if (viewIds.length) {\n        attributes.view = {\n            id: viewIds,\n        };\n    }\n    const longTaskIds = profilerTrace.longTasks.map((longTask) => longTask.id).filter((id) => id !== undefined);\n    if (longTaskIds.length) {\n        attributes.long_task = { id: longTaskIds };\n    }\n    return attributes;\n}\nexport const transport = {\n    sendProfile,\n};\n//# sourceMappingURL=transport.js.map","import { addEventListener, clearTimeout, setTimeout, monitorError, display, getGlobalObject, relativeToClocks, clocksOrigin, clocksNow, elapsed, } from '@datadog/browser-core';\nimport { RumPerformanceEntryType, supportPerformanceTimingEvent } from '@datadog/browser-rum-core';\nimport { getNumberOfSamples } from './utils/getNumberOfSamples';\nimport { cleanupLongTaskRegistryAfterCollection, getLongTaskId } from './utils/longTaskRegistry';\nimport { mayStoreLongTaskIdForProfilerCorrelation } from './profilingCorrelation';\nimport { transport } from './transport/transport';\nexport const DEFAULT_RUM_PROFILER_CONFIGURATION = {\n    sampleIntervalMs: 10, // Sample stack trace every 10ms\n    collectIntervalMs: 60000, // Collect data every minute\n    minProfileDurationMs: 5000, // Require at least 5 seconds of profile data to reduce noise and cost\n    minNumberOfSamples: 50, // Require at least 50 samples (~500 ms) to report a profile to reduce noise and cost\n};\nexport function createRumProfiler(configuration, lifeCycle, session, profilerConfiguration = DEFAULT_RUM_PROFILER_CONFIGURATION) {\n    const isLongAnimationFrameEnabled = supportPerformanceTimingEvent(RumPerformanceEntryType.LONG_ANIMATION_FRAME);\n    let lastViewEntry;\n    // Global clean-up tasks for listeners that are not specific to a profiler instance (eg. visibility change, before unload)\n    const globalCleanupTasks = [];\n    let instance = { state: 'stopped' };\n    function start(viewEntry) {\n        if (instance.state === 'running') {\n            return;\n        }\n        // Add initial view\n        // Note: `viewEntry.name` is only filled when users use manual view creation via `startView` method.\n        lastViewEntry = viewEntry\n            ? { startClocks: viewEntry.startClocks, viewId: viewEntry.id, viewName: viewEntry.name }\n            : undefined;\n        // Add global clean-up tasks for listeners that are not specific to a profiler instance (eg. visibility change, before unload)\n        globalCleanupTasks.push(addEventListener(configuration, window, \"visibilitychange\" /* DOM_EVENT.VISIBILITY_CHANGE */, handleVisibilityChange).stop, addEventListener(configuration, window, \"beforeunload\" /* DOM_EVENT.BEFORE_UNLOAD */, handleBeforeUnload).stop);\n        // Start profiler instance\n        startNextProfilerInstance();\n    }\n    async function stop() {\n        // Stop current profiler instance\n        await stopProfilerInstance('stopped');\n        // Cleanup global listeners\n        globalCleanupTasks.forEach((task) => task());\n        // Cleanup Long Task Registry as we no longer need to correlate them with RUM\n        cleanupLongTaskRegistryAfterCollection(clocksNow().relative);\n    }\n    /**\n     * Whenever a new Profiler instance is started, we need to add event listeners to surroundings (RUM Events, Long Tasks, etc) to enrich the Profiler data.\n     * If the instance is already running, we can keep the same event listeners.\n     */\n    function addEventListeners(existingInstance) {\n        if (existingInstance.state === 'running') {\n            // Instance is already running, so we can keep same event listeners.\n            return {\n                cleanupTasks: existingInstance.cleanupTasks,\n                observer: existingInstance.observer,\n            };\n        }\n        // Store clean-up tasks for this instance (tasks to be executed when the Profiler is stopped or paused.)\n        const cleanupTasks = [];\n        let observer;\n        // Register everything linked to Long Tasks correlations with RUM, when enabled.\n        if (configuration.trackLongTasks) {\n            // Setup event listeners, and since we only listen to Long Tasks for now, we activate the Performance Observer only when they are tracked.\n            observer = new PerformanceObserver(handlePerformance);\n            observer.observe({\n                entryTypes: [getLongTaskEntryType()],\n            });\n            // Whenever an Event is collected, when it's a Long Task, we may store the long task id for profiler correlation.\n            const rawEventCollectedSubscription = lifeCycle.subscribe(12 /* LifeCycleEventType.RAW_RUM_EVENT_COLLECTED */, (data) => {\n                mayStoreLongTaskIdForProfilerCorrelation(data);\n            });\n            cleanupTasks.push(() => observer === null || observer === void 0 ? void 0 : observer.disconnect());\n            cleanupTasks.push(rawEventCollectedSubscription.unsubscribe);\n        }\n        // Whenever the View is updated, we add a views entry to the profiler instance.\n        const viewUpdatedSubscription = lifeCycle.subscribe(2 /* LifeCycleEventType.VIEW_CREATED */, (view) => {\n            // Note: `view.name` is only filled when users use manual view creation via `startView` method.\n            collectViewEntry({ viewId: view.id, viewName: view.name, startClocks: view.startClocks });\n        });\n        cleanupTasks.push(viewUpdatedSubscription.unsubscribe);\n        return {\n            cleanupTasks,\n            observer,\n        };\n    }\n    function startNextProfilerInstance() {\n        // These APIs might be unavailable in some browsers\n        const globalThisProfiler = getGlobalObject().Profiler;\n        if (!globalThisProfiler) {\n            throw new Error('RUM Profiler is not supported in this browser.');\n        }\n        // Don't wait for data collection to start next instance\n        collectProfilerInstance(instance).catch(monitorError);\n        const { cleanupTasks, observer } = addEventListeners(instance);\n        let profiler;\n        try {\n            // We have to create new Profiler each time we start a new instance\n            profiler = new globalThisProfiler({\n                sampleInterval: profilerConfiguration.sampleIntervalMs,\n                // Keep buffer size at 1.5 times of minimum required to collect data for a profiling instance\n                maxBufferSize: Math.round((profilerConfiguration.collectIntervalMs * 1.5) / profilerConfiguration.sampleIntervalMs),\n            });\n        }\n        catch (e) {\n            // If we fail to create a profiler, it's likely due to the missing Response Header (`js-profiling`) that is required to enable the profiler.\n            // We should suggest the user to enable the Response Header in their server configuration.\n            display.warn('[DD_RUM] Profiler startup failed. Ensure your server includes the `Document-Policy: js-profiling` response header when serving HTML pages.', e);\n            return;\n        }\n        // Kick-off the new instance\n        instance = {\n            state: 'running',\n            startClocks: clocksNow(),\n            profiler,\n            timeoutId: setTimeout(startNextProfilerInstance, profilerConfiguration.collectIntervalMs),\n            longTasks: [],\n            views: [],\n            cleanupTasks,\n            observer,\n        };\n        // Add last view entry\n        collectViewEntry(lastViewEntry);\n        // Add event handler case we overflow the buffer\n        profiler.addEventListener('samplebufferfull', handleSampleBufferFull);\n    }\n    async function collectProfilerInstance(lastInstance) {\n        var _a, _b;\n        if (lastInstance.state !== 'running') {\n            return;\n        }\n        // Empty the performance observer buffer\n        handleLongTaskEntries((_b = (_a = lastInstance.observer) === null || _a === void 0 ? void 0 : _a.takeRecords()) !== null && _b !== void 0 ? _b : []);\n        // Cleanup instance\n        clearTimeout(lastInstance.timeoutId);\n        lastInstance.profiler.removeEventListener('samplebufferfull', handleSampleBufferFull);\n        // Store instance data snapshot in local variables to use in async callback\n        const { startClocks, longTasks, views } = lastInstance;\n        // Capturing when we stop the profiler so we use this time as a reference to clean-up long task registry, eg. remove the long tasks that we collected already\n        const collectClocks = clocksNow();\n        // Stop current profiler to get trace\n        await lastInstance.profiler\n            .stop()\n            .then((trace) => {\n            const endClocks = clocksNow();\n            const hasLongTasks = longTasks.length > 0;\n            const isBelowDurationThreshold = elapsed(startClocks.timeStamp, endClocks.timeStamp) < profilerConfiguration.minProfileDurationMs;\n            const isBelowSampleThreshold = getNumberOfSamples(trace.samples) < profilerConfiguration.minNumberOfSamples;\n            if (!hasLongTasks && (isBelowDurationThreshold || isBelowSampleThreshold)) {\n                // Skip very short profiles to reduce noise and cost, but keep them if they contain long tasks.\n                return;\n            }\n            handleProfilerTrace(\n            // Enrich trace with time and instance data\n            Object.assign(trace, {\n                startClocks,\n                endClocks,\n                clocksOrigin: clocksOrigin(),\n                longTasks,\n                views,\n                sampleInterval: profilerConfiguration.sampleIntervalMs,\n            }));\n            // Clear long task registry, remove entries that we collected already (eg. avoid slowly growing memory usage by keeping outdated entries)\n            cleanupLongTaskRegistryAfterCollection(collectClocks.relative);\n        })\n            .catch(monitorError);\n    }\n    async function stopProfilerInstance(nextState) {\n        if (instance.state !== 'running') {\n            return;\n        }\n        // Cleanup tasks\n        instance.cleanupTasks.forEach((cleanupTask) => cleanupTask());\n        await collectProfilerInstance(instance);\n        instance = { state: nextState };\n    }\n    function collectViewEntry(viewEntry) {\n        if (instance.state !== 'running' || !viewEntry) {\n            return;\n        }\n        // Add entry to views\n        instance.views.push(viewEntry);\n    }\n    function handleProfilerTrace(trace) {\n        var _a;\n        // Find current session to assign it to the Profile.\n        const sessionId = (_a = session.findTrackedSession()) === null || _a === void 0 ? void 0 : _a.id;\n        // Send JSON Profile to intake.\n        transport\n            .sendProfile(trace, configuration.profilingEndpointBuilder, configuration.applicationId, sessionId)\n            .catch(monitorError);\n    }\n    function handleSampleBufferFull() {\n        startNextProfilerInstance();\n    }\n    function handlePerformance(list) {\n        handleLongTaskEntries(list.getEntries());\n    }\n    function handleLongTaskEntries(entries) {\n        if (instance.state !== 'running') {\n            return;\n        }\n        for (const entry of entries) {\n            if (entry.duration < profilerConfiguration.sampleIntervalMs) {\n                // Skip entries shorter than sample interval to reduce noise and size of profile\n                continue;\n            }\n            const startClocks = relativeToClocks(entry.startTime);\n            const longTaskId = getLongTaskId(startClocks.relative);\n            // Store Long Task entry, which is a lightweight version of the PerformanceEntry\n            instance.longTasks.push({\n                id: longTaskId,\n                duration: entry.duration,\n                entryType: entry.entryType,\n                startClocks,\n            });\n        }\n    }\n    function handleVisibilityChange() {\n        if (document.visibilityState === 'hidden' && instance.state === 'running') {\n            // Pause when tab is hidden. We use paused state to distinguish between\n            // paused by visibility change and stopped by user.\n            // If profiler is paused by the visibility change, we should resume when\n            // tab becomes visible again. That's not the case when user stops the profiler.\n            stopProfilerInstance('paused').catch(monitorError);\n        }\n        else if (document.visibilityState === 'visible' && instance.state === 'paused') {\n            // Resume when tab becomes visible again\n            startNextProfilerInstance();\n        }\n    }\n    function handleBeforeUnload() {\n        // `unload` can in some cases be triggered while the page is still active (link to a different protocol like mailto:).\n        // We can immediately flush (by starting a new profiler instance) to make sure we receive the data, and at the same time keep the profiler active.\n        // In case of the regular unload, the profiler will be shut down anyway.\n        startNextProfilerInstance();\n    }\n    function getLongTaskEntryType() {\n        return isLongAnimationFrameEnabled ? 'long-animation-frame' : 'longtask';\n    }\n    function isStopped() {\n        return instance.state === 'stopped';\n    }\n    function isRunning() {\n        return instance.state === 'running';\n    }\n    function isPaused() {\n        return instance.state === 'paused';\n    }\n    return { start, stop, isStopped, isRunning, isPaused };\n}\n//# sourceMappingURL=profiler.js.map"],"names":["getNumberOfSamples","samples","numberOfSamples","sample","registry","setLongTaskId","longTaskId","startTime","getLongTaskId","cleanupLongTaskRegistryAfterCollection","collectionRelativeTime","performanceStartTime","mayStoreLongTaskIdForProfilerCorrelation","rawRumEvent","sendProfile","profilerTrace","endpointBuilder","applicationId","sessionId","event","buildProfileEvent","payload","buildProfilingPayload","profilingIntakeURL","addTelemetryDebug","tags","profileAttributes","buildProfileEventAttributes","profileEventTags","buildProfileEventTags","currentDrift","profileEvent","profilerTraceBlob","formData","attributes","viewIds","viewEntry","longTaskIds","longTask","id","transport","DEFAULT_RUM_PROFILER_CONFIGURATION","createRumProfiler","configuration","lifeCycle","session","profilerConfiguration","isLongAnimationFrameEnabled","supportPerformanceTimingEvent","RumPerformanceEntryType","lastViewEntry","globalCleanupTasks","instance","start","addEventListener","handleVisibilityChange","handleBeforeUnload","startNextProfilerInstance","stop","stopProfilerInstance","task","clocksNow","addEventListeners","existingInstance","cleanupTasks","observer","handlePerformance","getLongTaskEntryType","rawEventCollectedSubscription","data","viewUpdatedSubscription","view","collectViewEntry","globalThisProfiler","getGlobalObject","collectProfilerInstance","monitorError","profiler","e","display","setTimeout","handleSampleBufferFull","lastInstance","_a","_b","handleLongTaskEntries","clearTimeout","startClocks","longTasks","views","collectClocks","trace","endClocks","hasLongTasks","isBelowDurationThreshold","elapsed","isBelowSampleThreshold","handleProfilerTrace","clocksOrigin","nextState","cleanupTask","list","entries","entry","relativeToClocks","isStopped","isRunning","isPaused"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4]}